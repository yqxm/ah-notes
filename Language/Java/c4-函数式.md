# Java 函数式

## Lambda 表达式

Lambda 表达式产生函数，而不是类。虽然在 JVM 上所有东西都是类，但可以把它当成函数。

```java
h -> h + "s";

(h) -> h + "s";

() -> "s";

(h, n) -> h + n;

() -> {
    int a = 3;
    int b = 4;
    return a+b;
}
```

对于只有一个函数的接口，Lambda 表达式可以很方便的创建一个类似匿名内部类的对象。

### 递归

Lambda 表达式也可以写出递归的函数。但这个递归方法必须是一个实例变量或者静态变量。

## 方法引用

将类或对象的方法的名字赋给单方法接口来创建类似匿名内部类的对象。要求这个方法的参数和返回值要和接口中的方法一致。

```java
interface Callable {
    void call(String s);
}

class Describe {
    void show(String msg) {
        System.out.println(msg);
    }
}

class MethodReferences {

    public static void main(String[] args) {
        Describe d = new Describe();
        Callable c = d::show;
    }
}

```

### 无绑定方法引用

无绑定的方法引用需要传入对象。换句话说，要使用无绑定方法引用的接口的参数列表中需要定义那个方法引用的对象。

```java
class X {
    String f() { return "X::f()"; }
}
interface MakeString {
    String make();
}
interface TransformX {
    String transform(X x);
}
public class UnboundMethodReference {
    public static void main(String[] args) {
        // MakeString ms = X::f;
        TransformX sp = X::f;
        X x = new X();
        System.out.println(sp.transform(x));
    }
}
```

### 构造器方法引用

```java
class Dog {
    String name;
    int age = -1;
    Dog() {name = "stray";}
    Dog(String nm) {name = nm;}
    Dog(String nm, int yrs) {name=nm;age= yrs;}
}

interface MakeNoArgs {
    Dog make();
}

interface Make1Arg {
    Dog make(String nm);
}

interface Make2Args {
    Dog make(String nm, int age);
}

public class CtorReference {
    public static void main(String[] args) {
        MakeNoArgs mna = Dog::new;
        Make1Arg m1a = Dog::new;
        Make2Args m2a = Dog::new;

        Dog dn = mna.make();
        Dog d1 = m1a.make("Comet");
        Dog d2 = m2a.make("Ralph",4);
    }
}
```

## 函数接口

使用`@FunctionalInterface`来表明一个接口只包含一个抽象方法。

### function 工具包

`java.util.function`定义了一套函数接口。它的命名方式有一定的规律，可以方便使用

- 如果处理的是对象而不是基础类型。那它的名字就很直接，例如`Function Consumer Predicate`。处理的对象通过泛型表示
- 如果处理的是基础类型，它的前缀就是这个基础类型。例如`LongConsumer DoubleFunction`。`Supplier`例外
- 如果返回原始类型，则命名用 To 指明。例如`ToLongFunction<T> IntToLongFunction`。
- 如果返回值和参数类型相同，那用`operator`表示。`UnaryOperator`表示只有一个参数，`BinaryOperator`表示有两个参数。
- 如果接受两个参数并返回一个`boolean`，那用`Predicate`表示
- 如果两个参数是不同类型，那名字中包含`Bi`。

### 闭包(Closures)

Java8 提供了有限的闭包支持。

```java
public class Closure1 {
    int i;
    IntSupplier makeFun(int x) {
        return () -> x + i++;
    }
}
```

Closure1生成的IntSupplier共享同一个i。

```java
public class Closure2 {
    IntSupplier makefun(int x) {
        int i = 0;
        return () -> x + i;
    }
}
```

Closure2将i放在了方法内，可以编译成功，但失去了原有的意义。

```java
public class Closure3 {

    IntSupplier makefun(int x) {
        int i = 0;
        return () -> x++ + i++; // 出现编译错误
    }
}
```

Closure3给变量加了自增，出现编译错误(“lambda表达式中的local变量应该为final或者effectively final”)

```java
public class Closure4 {

    IntSupplier makefun(final int x) {
        final int i = 0;
        return () -> x + i;
    }
}
```

Closure4将x和i都变成了final，编译成功。和Closure2比较发现，Closure2中的变量是"effectively final"的，即从声明开始一直没有改变过，这也是为什么Closure2编译成功的原因。

```java
public class Closure5 {

    IntSupplier makefun(int x) {
        int i = 0;
        i++;
        x++;
//        effective final issue
        return () -> x + i;
    }
}
```

Closure5虽然没有在返回的函数中改变变量的值，但编译器仍旧认为变量不是"effective final"的。

```java
public class Closure6 {
    IntSupplier makeFun(int x) {
        int i = 0;
        i++;
        x++;
        final int iFinal = i;
        final int xFinal = x;
        return () -> xFinal + iFinal;
    }
}
```

Closure6将变量重新声明为final，编译成功。

```java
public class Closure7 {
    IntSupplier makeFun(int x) {
        Integer i = 0;
        i = i+1;
        // effective final issue
        return () -> x + i;
    }
}
```

Closure7将变量声明为了引用类型，编译器仍然能够检测出并报错。

```java
public class Closure8 {
    Supplier<List<Integer>> makeFun() {
        final List<Integer> ai = new ArrayList<>();
        ai.add(1);
        return () -> ai;
    }

    public static void main(String[] args) {
        Closure8 c8 = new Closure8();
        List<Integer> l1 = c8.makeFun().get();
        List<Integer> l2 = c8.makeFun().get();
        System.out.println(l1);
        System.out.println(l2);
        l1.add(42);
        l2.add(96);
        System.out.println(l1);
        System.out.println(l2);
    }
}
```

Closure8将变量声明为了list类型，这次编译成功。和Closure7比较发现，可能是对i的重新赋值发生了引用的变化，导致"effectively final isuue"。

```java
public class Closure9 {

    Supplier<List<Integer>> makeFun() {
        List<Integer> ai = new ArrayList<>();
        // ai = new ArrayList<>();  effective final issue
        return () -> ai;
    }
}
```

Closure9将list类型的变量重新赋值，又导致了"effectively final issue"。说明发生"effective final issue"的原因就是引用发生了变化。和Closure1比较发现，并不是所有在lambda之外定义的变量都需要是"final"或"effectively final"，只有当这个变量是"local"的，需要在方法结束后lambda以特殊方式捕捉的，才会出现"effective final issue"。

### 函数组合

- `andThen(argument)`   执行原始操作后再执行参数操作
- `compose(argument)`   执行参数操作后再执行原始操作
- `and(argument)`       执行短路的原始AND预测，然后是参数预测
- `or(argument)`        执行短路的原始OR预测，然后是参数预测
- `negate()`            当前预测的反面

### 柯里化

柯里化是指将一个需要多个参数的函数转化成一个函数序列，每个函数需要一个参数。
