# basic

## 基础

> 布尔类型

`_Bool`或者使用`stdbool.h`中的`bool`。

> 有符号数和无符号数比较会出现什么问题？

编译器会把有符号数转换成无符号数。

> 使用getchar和putchar有什么好处？

速度更快。一方面是因为`scanf`和`printf`除了输入输出还有模板处理，另一方面是因为使用了宏。

> sizeof运算符

指示指定类型存储所需的字节数。`sizeof`表达式的类型是`size_t`，使用前最好把它变成已知类型。在C99中，`printf`函数可以不进行转换，在转换说明前添加`z`就可以了。

## 数组

> 如何对数组初始化？

```c
int a[5] = {1,2,3,4,5};
int a[5] = {0};         //用0初始化 
int a[] = {1,2,3};      //指定初始化式可以不写数组的大小

// C99 only
int a[15] = {[2] = 29, [9] = 7};    //数组中第3个元素为29，第10个元素为7
```

> 如何确定数组的大小？

`sizeof`运算符可以确定数组占用的字节数

> 变长数组是怎样的？

```c
int n;
scanf("%d", &n);

int a[n];
```

变长数组的大小在它声明的时候是不确定的。运行时再进行确定，方便维护。

## 函数

> 实参和形参的差异

形参，函数调用时所需值的假名。实参，函数调用时候的表达式。

> 实参和形参的转换

调用前如果遇到函数的原型（声明或者完整定义），把实参转换成相应类型。如果没有遇到原型，则进行默认的实际参数提升。

> 数组型实际参数

数组也可以作为参数，但实际上传递的是指向数组开头的指针。如果利用数组型实际参数使用`sizeof`计算数组的长度就会出错，因为实际上计算的是指针的大小，指针占8个字节，得到数字8。

C99提供了一个变长数组形式参数，利用第一个参数，来指示数组的长度。

```c
// 这里n指示了数组的大小。数组中的n换成`*`也可以，这样更好的体现了数组和参数的关系
int sum_array(int n, int a[n]) {

}
```

C99提供了关键字`static`来确定数组参数的大小，但它仅可以用于第一维

```c
int sum_array(int a[static 3], int n) {

}
```

## 程序结构

> 局部变量的性质

- 自动存储期限： 在函数结束后局部变量失效。
- 块作用域： 局部变量仅在函数体内生效。

`static`关键字可以让局部变量变为静态存储期限，在整个程序运行期间它的值都会保留。同时它还有封装的功能。

> 外部变量的性质

- 静态存储期限： 类似static
- 文件作用域： 从开始声明的位置到文件结尾都可以使用它。

## 指针

> 变长数组和指针

如果变长数组是一维的，普通指针可以指向一维变长数组。

如果变长数组是多维的，指针的类型取决于除第一维外每一维的长度。

```c
void f(int m, int n) {
    int a[m][n], (*p)[n];
    p = a;
}
```

> `unsigned char*`和`char *`有什么区别？

...

## 字符串

> 为什么不要试图修改字符串字面量？

会导致未定义的行为，导致程序崩溃或不稳定。在gdb中测试中试图修改字符串字面量会报错，似乎那块内存是不允许修改的。

> 用数组声明和用指针声明的区别？

数组声明是可以修改字符串的，指针声明后，对指针指向对象的修改相当于修改字符串字面量。

> 操作字符串的库

使用`string.h`中的函数来对字符串进行操作。

> 字符串复制

`char *strcpy(char* s1, char* s2)`会把s2复制到s1中，如果s2的大小比s1大，会发生数组越界。

使用`strncpy(s1,s2,sizeof(s1))`可以限制复制的字符数。这可能会导致s1没有终止符。这时将最后一个位置设为空字符。
