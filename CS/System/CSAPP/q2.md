# 程序的机器级表示(x86-64)

## 程序编码

> 机器级编程中计算机系统给的两种重要抽象？

指令集架构和虚拟地址空间

> 程序计数器PC的作用？

指示下一条指令的位置

> 整数寄存器？

16个整数寄存器，存储整数或者地址。

> 条件码寄存器?

保存指令运算的状态。

> 程序内存中包含哪些信息？

管理内存的运行时栈，操作系统所需要的信息，程序的可执行机器代码，用户分配的内存快

> 汇编代码和可执行程序的反汇编需要注意些什么？

反汇编代码完全是根据可执行程序生成的，它可能和真正的汇编代码有些不同

## 数据格式

> Intel的数据格式？

Intel定义一个字有16位，用“word”表示，汇编后缀为w。双字32位，汇编后缀为l。四字64位，汇编后缀为q。单精度浮点数占32位，汇编后缀为l，双精度浮点数占64位，汇编后缀为q。

## 访问信息

> 通用目的寄存器有多少个？

16个。存储整数或者地址。%rax可以存储返回值，%rsp指明栈指针的位置，%rdi存储第一个参数，%rsi存储第二个参数。

> 操作数是什么，如何使用？

操作数指示一个操作中要使用的源数据。有三种指示数据的方式：

- 立即数： 使用一个确定的数值， 格式为$\$Imm$
- 寄存器： 使用寄存器中的值，格式为$r_a$
- 内存引用： 根据计算出来的内存地址，读取那个地址的值。

> 操作数对应的寻址方式是怎样的？

内存引用的寻址方式有很多中，但最基础的计算公式是$Imm(r_b, r_i, s)$，表示$Imm$加$r_b$加$r_i$乘以$s$的值，这个值就是要找的数的地址。

> 数据传送指令是怎样的？举一些数据传送指令的例子？

使用`mov`指令进行数据传送，他有两个操作数，第一个为源，第二个为目的。在x86-64中，任何为寄存器生成32位值的指令会把寄存器的高位设置为0

```armasm
movq %rax, -12(%rbp) 
```

> movq和movabsq指令

movq指令，当以立即数为源操作数时，只能是32位补码数字，然后扩展到64位。
movabsq可以传送绝对的四字立即数。并且只能以寄存器为目的。

> 带扩展的数据传送指令是怎样的？

movz指令使用零扩展，movs指令使用符号扩展。扩展后将数字传送给目标。

```armasm
movb $0xAA, %dl

# %rax = 0x00000000000000AA
movzbq %dl, %rax   
# %rax = 0xFFFFFFFFFFFFFFAA
movsbq %dl, %rax
```

> cltq指令

这个指令将符号扩展的%eax传送到%rax。

> 栈是怎样的？

%rsp寄存器中的值指明栈顶的位置。栈是向下增长的。

> 压栈和出栈操作指令？

push和pop指令进行压栈和出栈操作。两个指令都只有一个操作数。

push的操作数指明要被压入栈中的值。
pop的操作数指明出栈的数要存储的位置。

## 算数逻辑操作

> 加载有效地址指令？它是怎样进行算数逻辑操作的？

leaq指令是加载有效地址指令。它的源操作数和内存引用一样，但并不是读取那个地址的数据，而是读取这个地址。

我们知道内存引用经过计算获得地址，利用这个规则，可以使用leaq进行计算。

> 解释一元和二元操作

一元操作只有一个操作数，既是源也是目的。如INC,DEC,NEG,NOT

二元操作有两个操作数，第二个操作数既是源又是目的。如ADD,DUB,IMUL,XOR,OR.AND

> 解释移位操作

移位操作有两个操作数，第一个操作数为移位量，第二个操作数为要移位的值。移位量可以用立即数或者单字节寄存器%cl指明。

在x86-64中，对于w位的数据，%cl的低m位表示要移位的量，这里$2^m=w$。也就是说，若%cl的值为0xFF，那么`sahb`指令的移位量为7。

因为b代表是8位的数据，m=3,即低3位111=7。

> 有哪些特殊的算术操作？

- 乘法

64位乘法会产生128位的值。两个操作数的imulq指令只能用于产生64位的结果。

现增加了两条单操作数指令用于产生128位的值，imulq和mulq。他们要求一个参数必须存储在%rax中，另一个参数为操作数。然后乘积结果的高64位放在%rdx中，低64位放在%rax中。

- 除法

idivq和divq。除法和乘法类似，也是单操作数。被除数的高64位在%rdx中，低64位在%rax中，除数由操作数给出。指令将商存储在%rax中，将余数存储在%rdx中。

大多数除法应用中，被除数一般也是64位。这个值存放在%rax中，它的%rdx在无符号除法中设为全0，在有符号除法中设为符号。可以使用cqto指令来设置高位。它不需要操作数，隐含将%rax的符号位复制给%rdx。

## 控制

> 解释一下条件码？

算数或逻辑操作执行后，条件寄存器会记录下一些结果信息。包括是否进位，结果是否为0，结果是否溢出，结果是否为负数。

- CF(carry flag): 进位标志，检测最高位是否进位，可以用来指示无符号数的溢出。
- ZF(zero flag): 零标志，最近的结果是否为0。
- SF(signal flag): 符号标志，最近的结果是否为负数。
- OF(overflow flag): 溢出标志，最近的结果是否导致补码溢出。

> 算数逻辑操作对条件码的影响？

除了leaq指令是用来地址计算的以外，所有算数操作都会产生条件码。

XOR操作会把进位标志和溢出标志设为0。移位操作会把进位标志设为最后一个被移出的位，溢出标志设置为0。INC和DEC会设置溢出标志和零标志，但不会改变进位标志。

> 只设置条件码的操作

cmp指令和sub指令设置条件码的效果相同。

test指令和and指令设置条件码的效果相同。

> 怎样使用条件码？

- 根据条件码的组合，设置字节为0或者1。
- 条件跳转指令
- 条件传送数据

### set

> set指令是如何工作的？

set指令只有一个操作数，这个操作数是低位单字节寄存器，或者一个字节的内存位置。根据条件将这个字节设置为0或者1。

### 跳转指令

跳转指令会把程序执行跳转到一个全新的位置。jmp指令可以直接跳转，间接跳转，或者根据条件跳转。

汇编语言中：

- 直接跳转需要一个label。
- 间接跳转前面需要添加*号。

> 跳转指令的目标是如何编码的？

有多种编码方式。最常用的是PC相对寻址，其次是绝对地址。

> 什么是PC相对寻址？

利用目标指令和紧跟在跳转指令之后的指令之差来进行编码，这些地址偏移量可以为1、2或4个字节。例如，目标指令的地址为0x8，下一条指令的地址为0x5，则跳转指令的目标就编码为0x03。再如，目标指令的地址为0x5，下一条的地址为0xd，则跳转指令的目标地址为0xf8（编码为1个字节）。

> 如何使用条件控制来实现条件分支？

利用条件控制语句，满足条件则跳转

> 如何使用条件传送来实现条件分支?

将条件的两种情况都进行了计算，根据条件选择正确的结果。

> 汇编如何实现各种循环？

使用条件测试和跳转组合实现循环

> 汇编如何实现switch？

根据开关索引值进行跳转。

## 过程

> 什么是过程？

用参数和返回值封装一个功能。类似的其他名字还有函数、方法、子例程、处理函数。

> 支持机器级过程的机制

传递控制： 进入过程Q时，程序计数器为Q的地址，返回时是P中调用Q的下一条指令的地址。
传递数据： P必须能够向Q传递一个或多个参数，Q必须能够返回一个返回值。
分配和释放内存： 在开始时，Q可能需要为局部变量分配内存空间，返回时要释放这些内存空间。

### 运行时栈

> C语言过程调用的内存管理原则？

过程调用的关键机制是栈数据结构的后进先出的原则。

> 简单描述内存管理的过程？

当P调用Q,Q在执行的时候，P以及P以上的过程都被挂起。Q为自己的局部变量分配存储空间，或者设置一个新的调用。当Q返回时，释放掉分配的内存。

程序可以用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放这传递控制和数据、分配内存所需要的信息，当P调用Q时，这些信息被添加到栈尾，当Q返回时，这些信息会被释放。

> 什么时候需要在栈上分配空间？

过程需要的信息超过了寄存器能存储的信息。

> 什么是栈帧？

为过程分配的空间为栈帧。当前正在执行的过程的帧总是在栈顶。P调用Q的时候，会将返回地址压在栈顶，这部分属于P的栈帧，因为记录的是P相关的信息。

Q的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。

> 栈帧和函数

为了空间和时间效率，x86-64过程值分配自己所需要的栈帧部分。实际情况下，大多数函数不需要栈帧，因为参数可以保存在寄存器，且不需要调用其他函数。

### 转移控制

> 什么是转移控制？

将控制从P转移到Q只需要把程序计数器设为Q代码的起始位置。返回时，处理器使用之前记录的P调用Q之后的代码执行位置。

> 调用过程的指令

call指令调用，会将P的返回地址压入栈中，程序计数器设为Q的执行位置。
ret指令返回。将程序计数器设为P的返回地址。

调用分为直接调用和间接调用，间接调用在汇编代码中前面加*号。

### 数据传送

> 什么是数据传送？

除了控制，还要传递一些数据，比如参数和返回值。P调用Q时，首先要将一些参数存至寄存器，Q返回时P从%rax中获取返回值。

> 数据传送是如何实现的？

未超过6个参数时将参数放在寄存器，超过的部分由调用者P放入栈中。栈中的参数需要向8的倍数对齐。参数到位之后，再转移控制。

> 数据传送中参数和寄存器的关系？

按参数次序排列： %rdi %rsi %rdx %rcx %r8 %r9

### 栈上的局部存储

> 局部数据需要存放在内存中的情况？

- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用取地址符。
- 某些局部变量是数组或结构。

### 寄存器中的局部存储空间

> 如何保证寄存器中的值不被另一过程覆盖？

设计了一个所有寄存器都需要遵守的使用惯例。

寄存器%rbx、%rbp和%r12~%r15被划分为被调用者保存寄存器。当P调用Q时，Q必须保存这些寄存器的值。保证他们的值在Q返回到P还和原来一样。要保证不变，要么不去改变，要么标记为"保存的寄存器"压入栈中，在返回时弹出压入寄存器。

所有其他的寄存器，除了栈指针%rsp，都分类为调用者保存寄存器。这意味着任何函数都可以修改它们。虽然这些寄存器有P的局部数据，但保存这个局部数据是P的责任，所以可以任意修改。

### 递归过程

> 递归过程下的栈和寄存器是怎样的？

每个过程调用都在栈中有自己的私有空间。未完成的过程和过程之间的局部变量并不会互相影响。递归也和普通的函数调用一样。

## 数组的分配和访问

> 数组的分配和访问

对于声明 `T A[N]`。在内存中分配一个L*N的连续区域，L为T类型的大小。

用标识符A来作为只想数组开头的指针。数组元素i存放在$a+L*i$的地方

用内存引用指令可以简化数组的访问。

> & 和 * 的作用

&产生指针。

*间接引用指针。间接引用就是使用指针指向的值？

> 嵌套数组的内存使用

使用行优先的原则来进行顺序排列。

> 对变长数组的支持

...

## 异质的数据结构

> 两种创建数据类型的机制？

struct union

> 什么是结构？数据在内存中是怎样安排的？

将不同类型的对象聚合到一个对象中，使用名字来引用结构的各个组成部分。类似于数组，结构的所有组成部分都存放在一段连续的区域内。编译器维护关于每个结构的类型信息，指示每个字段的字节偏移。

> 如何产生指向结构内部对象的指针？

将结构的地址加上该字段的偏移量

> 什么是联合？它是怎样安排数据的？

多种类型引用同一段区域，即一个片段有多种表达方式。

> 联合的缺点和应用

...

> 什么是数据对齐？

计算机系统对某种数据类型的合法地址作了一些限制，要求某种类型对象的地址必须是某个值的倍数。

## 控制与数据的结合

> 理解指针

- 每个指针都对应一个类型
- 每个指针都有一个值
- 指针用&运算符创建
- *操作符用于间接引用指针
- 数组与指针联系紧密
- 将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值
- 指针也可以指向函数

> 内存越界引用？

越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行ret指令时，就会出现严重的错误。

> 缓冲区溢出导致的攻击

让程序执行它本来不愿意执行的函数。

> 对抗缓冲区溢出攻击的方式

- 栈随机化。栈地址不可预测。指向攻击代码的指针不能知道攻击代码的位置。
- 栈破坏检测。
- 限制可执行代码区域

> 什么情况下会需要变长栈帧？

使用alloca函数分配存储，或者声明一个局部变长数组

> 如何实现变长栈帧？

...

## 浮点代码

> YMM寄存器

AVX体系允许数据存储在16个YMM寄存器中。每个寄存器256位。操作标量数据时，这些寄存器只保存浮点数，且值使用低32位或64位。使用%xmm0~%xmm15来引用它们。每个XMM寄存器对应YMM的低128位。

> 如何进行浮点传送？

vmov指令

> 如何进行浮点转换？

...

> 过程中的浮点代码是怎样的？

...

> 汇编中的浮点运算

...

> 汇编中定义和使用浮点常数

...

> 浮点代码的位级操作

...

> 浮点代码的比较操作

...
