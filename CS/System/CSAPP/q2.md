# 程序的机器级表示(x86-64)

## 程序编码

> 机器级编程中计算机系统给的两种重要抽象？

指令集架构和虚拟地址空间

> 程序计数器PC的作用？

指示下一条指令的位置

> 整数寄存器？

16个整数寄存器，存储整数或者地址。

> 条件码寄存器?

保存指令运算的状态。

> 程序内存中包含哪些信息？

管理内存的运行时栈，操作系统所需要的信息，程序的可执行机器代码，用户分配的内存快

> 汇编代码和可执行程序的反汇编需要注意些什么？

反汇编代码完全是根据可执行程序生成的，它可能和真正的汇编代码有些不同

## 数据格式

> Intel的数据格式？

Intel定义一个字有16位，用“word”表示，汇编后缀为w。双字32位，汇编后缀为l。四字64位，汇编后缀为q。单精度浮点数占32位，汇编后缀为l，双精度浮点数占64位，汇编后缀为q。

## 访问信息

> 通用目的寄存器有多少个？

16个。存储整数或者地址。%rax可以存储返回值，%rsp指明栈指针的位置，%rdi存储第一个参数，%rsi存储第二个参数。

> 操作数是什么，如何使用？

操作数指示一个操作中要使用的源数据。有三种指示数据的方式：

- 立即数： 使用一个确定的数值， 格式为$\$Imm$
- 寄存器： 使用寄存器中的值，格式为$r_a$
- 内存引用： 根据计算出来的内存地址，读取那个地址的值。

> 操作数对应的寻址方式是怎样的？

内存引用的寻址方式有很多中，但最基础的计算公式是$Imm(r_b, r_i, s)$，表示$Imm$加$r_b$加$r_i$乘以$s$的值，这个值就是要找的数的地址。

> 数据传送指令是怎样的？举一些数据传送指令的例子？

使用`mov`指令进行数据传送，他有两个操作数，第一个为源，第二个为目的。在x86-64中，任何为寄存器生成32位值的指令会把寄存器的高位设置为0

```armasm
movq %rax, -12(%rbp) 
```

> movq和movabsq指令

movq指令，当以立即数为源操作数时，只能是32位补码数字，然后扩展到64位。
movabsq可以传送绝对的四字立即数。并且只能以寄存器为目的。

> 带扩展的数据传送指令是怎样的？

movz指令使用零扩展，movs指令使用符号扩展。扩展后将数字传送给目标。

```armasm
movb $0xAA, %dl

# %rax = 0x00000000000000AA
movzbq %dl, %rax   
# %rax = 0xFFFFFFFFFFFFFFAA
movsbq %dl, %rax
```

> cltq指令

这个指令将符号扩展的%eax传送到%rax。

> 栈是怎样的？

%rsp寄存器中的值指明栈顶的位置。栈是向下增长的。

> 压栈和出栈操作指令？

push和pop指令进行压栈和出栈操作。两个指令都只有一个操作数。

push的操作数指明要被压入栈中的值。
pop的操作数指明出栈的数要存储的位置。

## 算数逻辑操作

> 加载有效地址指令？它是怎样进行算数逻辑操作的？

leaq指令是加载有效地址指令。它的源操作数和内存引用一样，但并不是读取那个地址的数据，而是读取这个地址。

我们知道内存引用经过计算获得地址，利用这个规则，可以使用leaq进行计算。

> 解释一元和二元操作

一元操作只有一个操作数，既是源也是目的。如INC,DEC,NEG,NOT

二元操作有两个操作数，第二个操作数既是源又是目的。如ADD,DUB,IMUL,XOR,OR.AND

> 解释移位操作

移位操作有两个操作数，第一个操作数为移位量，第二个操作数为要移位的值。移位量可以用立即数或者单字节寄存器%cl指明。

在x86-64中，对于w位的数据，%cl的低m位表示要移位的量，这里$2^m=w$。也就是说，若%cl的值为0xFF，那么`sahb`指令的移位量为7。

因为b代表是8位的数据，m=3,即低3位111=7。

> 有哪些特殊的算术操作？

- 乘法

64位乘法会产生128位的值。两个操作数的imulq指令只能用于产生64位的结果。

现增加了两条单操作数指令用于产生128位的值，imulq和mulq。他们要求一个参数必须存储在%rax中，另一个参数为操作数。然后乘积结果的高64位放在%rdx中，低64位放在%rax中。

- 除法

idivq和divq。除法和乘法类似，也是单操作数。被除数的高64位在%rdx中，低64位在%rax中，除数由操作数给出。指令将商存储在%rax中，将余数存储在%rdx中。

大多数除法应用中，被除数一般也是64位。这个值存放在%rax中，它的%rdx在无符号除法中设为全0，在有符号除法中设为符号。可以使用cqto指令来设置高位。它不需要操作数，隐含将%rax的符号位复制给%rdx。

## 控制

> 解释一下条件码？

算数或逻辑操作执行后，条件寄存器会记录下一些结果信息。包括是否进位，结果是否为0，结果是否溢出，结果是否为负数。

- CF(carry flag): 进位标志，检测最高位是否进位，可以用来指示无符号数的溢出。
- ZF(zero flag): 零标志，最近的结果是否为0。
- SF(signal flag): 符号标志，最近的结果是否为负数。
- OF(overflow flag): 溢出标志，最近的结果是否导致补码溢出。

> 算数逻辑操作对条件码的影响？

除了leaq指令是用来地址计算的以外，所有算数操作都会产生条件码。

XOR操作会把进位标志和溢出标志设为0。移位操作会把进位标志设为最后一个被移出的位，溢出标志设置为0。INC和DEC会设置溢出标志和零标志，但不会改变进位标志。

> 只设置条件码的操作

cmp指令和sub指令设置条件码的效果相同。

test指令和and指令设置条件码的效果相同。

> 怎样使用条件码？

- 根据条件码的组合，设置字节为0或者1。
- 条件跳转指令
- 条件传送数据

### set

> set指令是如何工作的？

set指令只有一个操作数，这个操作数是低位单字节寄存器，或者一个字节的内存位置。根据条件将这个字节设置为0或者1。

### 跳转指令

跳转指令会把程序执行跳转到一个全新的位置。jmp指令可以直接跳转，间接跳转，或者根据条件跳转。

汇编语言中：

- 直接跳转需要一个label。
- 间接跳转前面需要添加*号。

> 跳转指令的目标是如何编码的？

有多种编码方式。最常用的是PC相对寻址，其次是绝对地址。

> 什么是PC相对寻址？

利用目标指令和紧跟在跳转指令之后的指令之差来进行编码，这些地址偏移量可以为1、2或4个字节。例如，目标指令的地址为0x8，下一条指令的地址为0x5，则跳转指令的目标就编码为0x03。再如，目标指令的地址为0x5，下一条的地址为0xd，则跳转指令的目标地址为0xf8（编码为1个字节）。

> 如何使用条件控制来实现条件分支？

...

> 如何使用条件传送来实现条件分支?

...

> 汇编如何实现各种循环？

...

> 汇编如何实现switch？

...

## 过程

> 什么是过程？

...

> 支持机器级过程的机制

...

### 运行时栈

> C语言过程调用的内存管理原则？

...

> 简单描述内存管理的过程？

...

> 什么时候需要在栈上分配空间？

...

> 什么是栈帧？

...

> 栈帧和函数

...

### 转移控制

> 什么是转移控制？

...

> 调用过程的指令

...

### 数据传送

> 什么是数据传送？

...

> 数据传送是如何实现的？

...

> 数据传送中参数和寄存器的关系？

...

## 栈上的局部存储

> 局部数据需要存放在内存中的情况？

...

### 寄存器中的局部存储空间

> 如何保证寄存器中的值不被另一过程覆盖？

...

> x86-64寄存器使用惯例

...

### 递归过程

> 递归过程下的栈和寄存器是怎样的？

...

## 数组的分配和访问

> 内存引用和数组访问

...

> & 和 * 的作用

...

> 嵌套数组的内存使用

...

> 编译器如何访问多维数组元素？

...

> GCC对定长数组的一些优化

...

> 对变长数组的支持

...

> 编译器的变长数组的优化

...

## 异质的数据结构

> 两种创建数据类型的机制？

...

> 什么是结构？数据在内存中是怎样安排的？

...

> 如何产生指向结构内部对象的指针？

...

> 什么是联合？它是怎样安排数据的？

...

> 联合的缺点和应用

...

> 什么是数据对齐？

...

## 控制与数据的结合

> 理解指针

...

> 什么情况下会出现内存越界？会导致什么错误？

...

> 缓冲区溢出导致的攻击

...

> 对抗缓冲区溢出攻击的方式

...

> 什么情况下会需要变长栈帧？

...

> 如何实现变长栈帧？

...

## 浮点代码

> YMM寄存器

...

> 如何引用YMM寄存器？

...

> 如何进行浮点传送？

...

> 如何进行浮点转换？

...

> 过程中的浮点代码是怎样的？

...

> 汇编中的浮点运算

...

> 汇编中定义和使用浮点常数

...

> 浮点代码的位级操作

...

> 浮点代码的比较操作

...
