# 预处理器

## 指令

> `#define` 和 `#undef`

定义和删除一个宏。宏，常量或表达式的别名。

> `#include`

指定一个文件包含到程序中

> `#if #ifdef #ifndef #elif #else #endif`

根据预处理器可以知道的条件来决定是否将一个片段添加到程序中。

## 宏

> 简单的宏是怎样的？

`#define 标识符 替换列表`

替换列表可以包括标识符，关键字，数值常量，字符常量，字符串字面量。当预处理器遇到一个宏定义时，会将标识符替换为替换列表中的内容。

> 带参数的宏是怎样的？

`#define 标识符(x1,x2,...,xn) 替换列表`

标识符和左括号之间不能有空格，否则预处理器会当成简单的宏进行处理。

> 使用宏的缺点

宏可能会不止一次的计算它的参数。尽量不要让参数带有副作用。

> `#`运算符

将宏的一个参数转换为字符串字面量。它仅允许出现在带参数的宏的替换列表中。

> `##`运算符

记号粘合

```c
#define GENERIC_MAX(type) \
    type type##_max(type x, type y) {

    }
```

> 宏的通用属性？

- 宏的替换列表可以包含对其他宏的调用
- 预处理器只会替换完整的记号
- 宏的作用范围到出现这个宏的文件末尾
- 宏不可以被定义两遍，除非两遍定义相同
- 可以使用`#undef`来取消宏定义

> 为什么圆括号如此重要？如何使用？

最主要的原因是让表达式的表达没有歧义。

比如

```c
#define TWO_PI 2*3.14

int main() {
    printf("%f", 5.0/Two_PI);
}
```

在这种情况下，宏展开变成`5.0/2*3.14`。与预期不符

```c
#define SCALE(x) (x*10)

int main() {
    int i = 10;
    printf(SCALE(i+1));   
}
```

在这种情况下，宏展开变为`i+1*10`。 与预期不符

两个规则：

- 如果替换列表中有运算符，则使用圆括号包围。
- 如果宏有参数，则参数在替换列表中的每次出现都要使用圆括号。

> 如何创建较长的宏？

使用逗号运算符或者花括号。

逗号：

```c
#define ECHO(s) (gets(s), puts(s))

ECHO(str);  // 替换为 (gets(str), puts(str));
```

花括号：

```c
#define ECHO(s) {gets(s); puts(s);}
```

但有的时候花括号并未奏效

```c
if (echo_flag)
    ECHO(s);
else
    gets(str)
```

`ECHO(s);` 被展开为`{gets(s);puts(s);} ;` 外面多了一个分号，导致if不能正常工作。

改进的方法是使用do-while

```c
#define ECHOS (do {gets(s); puts(s);} while(0))
```

让循环只执行一次，注意`while(0)`后面没有分号。

> 一些预定义的宏

- `__LINE__` 被编译的文件中的行号
- `__FILE__` 被编译的文件名
- `__DATE__` 编译的日期
- `__TIME__` 编译的时间
