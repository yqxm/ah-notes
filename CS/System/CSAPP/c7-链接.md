# 链接

Linking is the process of collecting and combining various pieces of code and data into a single file that can be _loaded_ into memory and excuted.

Linking can be performed at _compile time_, when the source code is translated into machine code; at _load time_, when the program is loaded into memory and excuted by the _loader_; and even at _run time_, by application programs.

Linkers enable _separate compilation_.

## Compiler Drivers

Most compilation systems provide a _compiler driver that invokes the language preprocessor, compiler, assembler, and linker, as needed on behalf of the user.

First, the driver runs the C preprocessor(cpp), which translate the C source file main.c into an ASCII intermediate file `main.i`.

```bash
cpp [other args] main.c /tmp/main.i
```

Next, the driver runs the C compiler(cc1), which translates `main.i` into an ASCII assembly-language file `main.s`.

```bash
cc1 /tmp/main.i -Og [other args] -o /tmp/main.s
```

Then, the driver runs the assembler(as), which translate `main.s` into a binary _relocatable object file_ `main.o`.

```bash
as [other args] -o /tmp/main.s /tmp/main.s
```

The driver goes througn the same process to generate `sum.o`.

Finally, it runs the linker program ld, which combines `main.o` and `sum.o`, along with the necessary system object files, to create the binary _executable object file_.

```bash
ld -o prg [system obj files and args] /tmp/main.o /tmp/sum.o
```

The shell invokes a function called _loader_, which copies the code and data in the executable file `prog` into memory, and then transfers control to the beginning of the program.

## Static Linking

_Static Linker_ such as the Linux LD program take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked excutable object file.

The input relocatable object files consist of various code and data sections. Each section is a contiguous sequence of bytes. _Instructions_, _Initialized global variables_, _Uninitialized variables_ are in separate sections.

Linker's two main task:

- **Symbol resolution**: Object files define and reference _symbols_, where each symbol correspond to a function, a global variable, or a _static variable_. The purpose of symbol resolution is to associate each symbol _reference_ with exactly one symbole _definition_

- **Relocation**: Compilers and assemblers generate code and data sections that start at address 0. The linker _relocates_ these sections by associating a memory location with each symbol definition, and then modifying all of the references to those symbols so that they point to this memory location.

Basic fact: Object files are merely collections of blocks of bytes.

## Object files

Three forms of object files:

- Relocatable object file
- Excutable object file
- Shared object file

## Relocatable Object files

The _ELF header_ begins with a 16-byte sequence that describes the word size and byte ordering of the system that generate the file. The rest of the ELF header contains information that allows alinker to parse and interpret the object file

sections between ELF header and the section header:

- .text: the machine code of the compiled program
- .rodata: Read-only data such as the format strings in printf statemens and jump tables for switch statements
- .data: _Initialized_ global and static C variables.
- .bss: _Uninitialized_ global and static C variables, along with any global or static variables that are initialized to zero.
- .symtab: A _symbol table_ with information about functions and global variables that defined and referenced in the program.
- .rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object file with others.
- .rel.data: Relocation information for any global variables that are referenced or defined by the module.
- .debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file.
- .line: A mapping between line numbers in the original C source program and machine code instructions in the .text section.
- .strtab: A string table for the symbol tables in the .symtab and .debug sections and for the section names in the section headers.

## Symbols and Symbol Tables

Each relocatable object module has a table that contains the information about the symbols that are defined and referenced by it. There are three kind of symbols

- Global symbols that are defined by module m that can be referenced by other modules.
- Global symbols that are referenced by module m but defined by some other module.
- _Local symbols_ that are defined and referenced exclusively by module m.

## Symbol Resolution

The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files.

It's straightforward for references to local symbols that are defined in the same module as reference. The compiler allows only one definition of each local symbol per module.

### How to resolve duplicate global symbols

At compile time, the compiler exports each global symbol to the assembler as either _strong_ or _weak_, and the assembler encodes this information implictly in the symbol table of the relocatable object file.

- Functions and initialized global variables get strong symbols.
- Uninitialized global variables get weak symbols.

Rules for dealing duplicate symbol names.

- Multiple strong symbols withe same name are not allowed.
- Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.
- Given multiple weak symbols with the same name, choose any of the weak symbols.

### Linking with Static Libraries

All compilation systems provide a mechanism for packaging related object modules into a single file called a _static library_, which can then be supplied as input to the linker.

Related functions can be compiled into separate object modules and the packaged in a single static library file. Application programs can use any of the functions defined in the library by specifying a single filename on the commandline.

### How linkers use static libraries to resolve references

During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver's command line.

During this scan, the linker maintains a set _E_ of relocatable object files that will merged to form the executable, a set _U_ of unresolved symbols, a set _D_ of symbols that have been defined in previous input files. Initially, _E_,_U_, and _D_ are empty.

- For each input file _f_ on the command line, the linker determines if _f_ is an object file or an archive. if _f_ is an object file, the linker adds _f_ to _E_, updates _U_ and _D_ to reflect the symbol definitions and references in _f_, and proceeds to the next input file.
- if _f_ is an archive, the linker attempts to match the unresolved symbols in _U_ against the symbols defined by the members of the archive. If some archive member _m_ defines a symbol that resolves a resolves a references in _U_, then _m_ is added to _E_, and the linker updates _U_ and _D_ to reflect the symbol definitions and references in _m_. This process iterates over the member object files in the archive until a fixed point is reached where _U_ and _D_ no longer change. At this point, any member object files not contained in _E_ are simply discarded and the linker proceeds to the next input file.
- If _U_ is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in _E_ to build the output executable file.

This algorithm can result in some baffling link-time errors because the ordering of libraries and object files on the command line is significant. If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linkingwill fail.

The general rule for libraries is to place them at the end of the command line. If the libraries are not independent, they must be ordered.

## Relocation
