# 程序的机器级表示(x86-64)

## 程序编码

```bash
linux> gcc -Og -o p p1.c p2.c
```

编译选项`-Og`告诉编译器不进行优化，生成符合原始`C`结构的机器级代码。

### 机器级代码

可见的处理器状态：

- 程序计数器：给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件：包含 16 个命名的位置，分别存储 64 位的值。
- 条件码寄存器：保存最近的算数或逻辑指令的状态信息。实现控制或数据流中的条件变化
- 一个向量寄存器可以存储一个或多个整数或浮点数值。

一条机器指令只执行一个基本操作。

选项`-c`编译并汇编代码

```bash
linux> gcc -Og -c  mstore.c
```

使用`Objdump -d`来进行反汇编

```bash
linux> objdump -d mstore.o
```

机器代码和它的反汇编的一些特性：

- x86-64 指令的长度从 1-15 不等。越不常用的指令越长。
- 设计指令代码的格式是：从某个给定位置开始，可以将字节唯一的解释成机器指令
- 反汇编器根据机器代码文件中的字节序列来确定汇编代码。
- 反汇编器使用的指令命名规则和 GCC 生成的汇编代码有细微的差别

## 数据格式

Intel 用"字"代表 16 位数据类型。32 位为双字，64 位为四字

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小(字节) |
| :----: | :------------: | :----------: | :--------: |
|  char  |      字节      |      b       |     1      |
| short  |       字       |      w       |     2      |
|  int   |      双字      |      l       |     4      |
|  long  |      四字      |      q       |     8      |
| char\* |      四字      |      q       |     8      |
| float  |     单精度     |      s       |     4      |
| double |     双精度     |      l       |     8      |

大多数 gcc 生成的汇编代码都有一个后缀，表明操作的数据大小。

## 访问信息

一个 x86-64cpu 包含一组 16 个存储 64 位值的**通用目的寄存器**。这些寄存器用来存储整数和指针。

指令可以对寄存器的低位字节进行操作。操作 1 个字节，2 个字节，4 个字节或 8 个字节。操作可能对高位字节有影响。

不同的寄存器扮演不同的角色。

### 操作数指示符

三种类型

- 立即数：用来表示常数值
- 寄存器：用来表示寄存器的内容，用符号$r_a$表示任意寄存器 a,$R[r_a]$表示它的值
- 内存引用：根据计算出来的地址访问内存位置。用$M_b[Addr]$来表示在内存$Addr$开始的$b$个字节值的引用

内存引用的寻址模式： $Imm(r_b, r_i, s)$是最常用的形式。它的有效地址为$R[r_b]+R[r_i]*s$。

### 数据传送指令

#### MOV 类

源操作数制定为一个立即数，存储在寄存器或者内存中。目的操作数制定为一个位置，要么是寄存器，要么是内存地址。x86-64 规定源操作数和目的操作数不能都指向内存。

`mov`指令后可以跟`b`、`w`、`l`、`q`。分别表示移动的是字节，字，双字，四字。

大多数情况下，`mov`只会改变对应长度的数据。但例外情况是，当`movl`指令的目的是寄存器时，寄存器的高位 4 字节会设置为 0。原因是 x86-64 的惯例，任何为 32 位寄存器生成值的操作都会把该寄存器的高 32 位设置为 0。

##### movabsq

常规的`movq`只能以表示为 32 位补码的立即数作为源操作数，然后把这个值符号扩展到 64 位存储到目标位置。而`movabsq`能够以任意 64 位立即数作为源操作数，并且只能以寄存器作为目的。

#### MOVZ 和 MOVS

这两类指令以内存或寄存器作为源，以寄存器作为目的，并且将较小的源传送到较大的目的。`movz`将目的的高位填充为 0，`movs`根据源的最高位进行符号扩展。

例子：

- `movzbw`：将做了零扩展的字节传送到字
- `movsbw`：将做了符号扩展的字节传送到字

理论上应该有`movzlq`，但可以通过`movl`实现，所以没有`movzlq`。

### 压入和弹出栈操作

push 操作将数据压入栈中。pop 操作将数据从栈中弹出。都只有一个操作数

栈遵循后进先出的原则。出的位置被称为“栈顶”。

在 x86-64 中，栈向下增长。“栈顶”在最低位，栈指针`%rsp`指向栈顶的位置。

将一个四字值压入栈中，栈指针减 8，然后将值写入新的栈顶地址

## 算数和逻辑操作

### 加载有效地址

`leaq`指令将有效地址写入到目的操作数。目的操作数必须为寄存器

第一个操作数的形式是内存引用，这样它就可以进行一些简单的计算。

### 一元操作

`INC`、`DEC`、`NEG`、`NOT`是一元操作。操作数既是源也是目的，操作数为寄存器或者内存位置。

`incq(%rsp)`会使栈顶的 8 字节元素加 1。

### 二元操作

`ADD`、`SUB`、`IMUL`、`XOR`、`OR`、`AND`是二元操作。第二个操作数既是源也是目的。

第一个操作数可以是寄存器，立即数或者内存地址。第二个操作数可以是寄存器或者内存地址。当第二个操作数是内存地址时，数据从内存读出，计算后在存储到内存中。

### 移位操作

`SAL`、`SHL`、`SAR`、`SHR`是移位操作。

第一个数给出移位量，可以是立即数，或者在单字节寄存器`%c1`中。第二个数给出要移位的数。

A 代表算数移位，H 代表逻辑移位。

理论上移位量可以达到$2^8-1$,但在 x86-64 中，移位量由`%cl`寄存器的低$m$决定，其中$2^m=w$。$w$代表要操作的数据值的位数。

### 特殊的算术操作

`imulq`有两种形式

- 双操作数：从两个 64 位操作数产生一个 64 位乘积
- 单操作数：计算两个 64 位补码值的全 128 位乘积。

`mulq`计算两个 64 位无符号值的全 128 位乘积。和单操作数时的`imulq`一样，要求一个参数必须存放在寄存器`%rax`中，另一个以源操作数给出。然后将乘积存放在`%rdx`（高 64 位）和`%rax`（低 64 位）中。

汇编器根据`imulq`的操作数来判断执行哪种操作。

除法和取模操作由单操作数`idivq`，`divq`来提供。将寄存器`%rdx`存储高 64 位，`%rax`来存储低 64 位作为被除数。除数由指令的操作数提供。商保存在`%rax`中，余数保存在`%rdx`中。

`cqto`指令没有操作数，它隐含读出`%rax`的符号位，并复制到`%rdx`的所有位

## 控制

### 条件码

除了整数寄存器，CPU 还维护了一组**单个位**的条件码寄存器，用来描述最近的算术或逻辑操作的属性。

最常用的条件码：

- CF：进位标志
- ZF：零标志
- SF：符号标志。最近的操作结果为负数
- OF：溢出标志

`leaq`指令不改变任何条件码，因为它是进行地址计算的。除它以外，之前算术逻辑操作下的指令都会设置条件码。对于逻辑操作，例如`XOR`会将进位和溢出操作设置为 0。对于移位操作，进位标志会设置成最后一个被移出的位，溢出标志设置为 0。`INC`和`DEC`会设置溢出和零标志，但不改变进位标志。

`CMP`和`TEST`只改变条件码而不改变任何其他寄存器。

`CMP`行为和`SUB`一样。如果操作数相等，ZF(零标志)设置为 1。其他标志可以判断两个数的大小

`TEST`行为和`AND`一样。典型的应用是，两个操作数相等，判断这个操作数是负数，0 还是正数。或者其中一个数为掩码，指示哪些位应该被测试。

|    指令    |  基于   |   描述   |
| :--------: | :-----: | :------: |
| CMP S1,S2  | S2 - S1 |   比较   |
|    cmpb    |         | 比较字节 |
|    cmpw    |         |  比较字  |
|    cmpl    |         | 比较双字 |
|    cmpq    |         | 比较四字 |
|            |         |          |
| TEST S1,S2 |  S1&S2  |   测试   |
|   testb    |         | 测试字节 |
|   testw    |         |  测试字  |
|   testl    |         | 测试双字 |
|   testq    |         | 测试四字 |

### 访问条件码

不直接读取条件码，而是通过其他方式使用它：

- 通过条件码的组合将一个字节设置为 0 或 1。
- 根据条件跳转到程序的其它部分
- 有条件地传输数据

根据条件码组合设置字节的指令为`set`指令。它的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1。

|  指令   | 同义名 |              效果               | 设置条件  |
| :-----: | :----: | :-----------------------------: | :-------: |
| sete D  |  setz  |        D $\leftarrow$ ZF        |  相等/零  |
| setne D | setnz  |       D $\leftarrow$ ~ZF        | 不等/非零 |
| sets D  |        |        D $\leftarrow$ SF        |   负数    |
| setns D |        |       D $\leftarrow$ ~SF        |  非负数   |
| setg D  | setnle | D $\leftarrow$ ~(SF ^ OF) & ~ZF |  有符号>  |
| setge D | setnl  |    D $\leftarrow$ ~(SF ^ OF)    | 有符号>=  |
| setl D  | setnge |     D $\leftarrow$ SF ^ OF      |  有符号<  |
| setle D | setng  |  D $\leftarrow$ SF ^ OF \| ZF   | 有符号<=  |
| seta D  | setnbe |    D $\leftarrow$ ~CF & ~ZF     |  无符号>  |
| setae D | setnb  |       D $\leftarrow$ ~CF        | 无符号>=  |
| setb D  | setnae |        D $\leftarrow$ CF        |  无符号<  |
| setbe D | setna  |     D $\leftarrow$ CF \| ZF     | 无符号<=  |

### 跳转指令

跳转指令会导致程序切换到一个全新的位置。这个位置通常由标号$Label$指明。

`jmp`指令是无条件跳转。它既可以*直接*跳转，跳转目标是作为指令的一部分编码的。也可以是*间接*跳转，跳转目标从寄存器或内存位置读出。

|      指令      | 同义词 |     跳转条件     |   描述   |
| :------------: | :----: | :--------------: | :------: |
|  jmp $Label$   |        |        1         | 直接跳转 |
| jmp $*Operand$ |        |        1         | 间接跳转 |
|   je $Label$   |   jz   |        ZF        |   相等   |
|  jne $Label$   |  jnz   |       ~ZF        |  不相等  |
|   js $Label$   |        |        SF        |   负数   |
|  jns $Label$   |        |       ~SF        |  非负数  |
|   jg $Label$   |  jnle  | ~(SF ^ OF) & ~ZF | 有符号>  |
|  jge $Label$   |  jnl   |    ~(SF ^ OF)    | 有符号>= |
|   jl $Label$   |  jnge  |     SF ^ OF      | 有符号<  |
|  jle $Label$   |  jng   | (SF ^ OF) \| ZF  | 有符号<= |
|   ja $Label$   |  jnbe  |    ~CF & ~ZF     | 无符号>  |
|  jae $Label$   |  jnb   |       ~CF        | 无符号>= |
|   jb $Label$   |  jnae  |        CF        | 无符号<  |
|  jbe $Label$   |  jna   |     CF \| ZF     | 无符号<= |

#### 跳转指令的编码

- PC-relative: PC 相对编码，将目标指令的地址与紧跟在跳转指令的后面那条指令之间的差作为编码，可以编码为 1，2，或 4 个字节。
- “绝对”地址：用四个字节直接指定目标。

```armasm
0: 48 89 f8            mov     %rdi,%rax
3: eb 03               jmp     8 <loop+0x8>
5: 48 d1 f8            sar     %rax
8: 48 85 c0            test    %rax,%rax
b: 7f f8               jg      5 <loop+0x5>
d: f3 c3               repz retq
```

可以看到 jmp 指令所在行左边*0x03*作为编码，它加上下一条指令的位置*0x5*就是要跳转的位置*0x8*。

类似地，jg 指令要跳转的位置是*0x5*,将*0x5*减去下一条指令的位置*0xd*,得到*0xf8*作为编码。

#### 用条件控制来实现条件分支

`CMP`或`TEST`指令改变条件码，然后使用条件跳转指令进行跳转实现条件分支。

#### 用条件传送来实现条件分支

使用*控制*的条件转移简单通用，但非常低效。

一种替代的策略是使用*数据*的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。

只有在一些受限制的情况中，这种策略才可行，但如果可行，就可以用一条简单的*条件传送*指令来实现它。

##### 为什么条件传送更快？

CPU 通过使用*流水线*来获取高性能。在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一部分。而流水线要获取高性能，需要重叠连续指令的步骤，例如，在取一条指令的同时，计算它前面指令的算数运算。这要求能够事先确定执行的指令序列，以保持流水线中充满了待执行的指令。当机器遇到条件跳转时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用*分支预测逻辑*来猜测跳转指令是否执行。只要猜测比较可靠，流水线就会充满指令，而错误预测会导致严重的惩罚。条件传送不需要进行这样的预测，也就没有惩罚。

条件传送指令有两个操作数：源寄存器或者内存地址$S$，目的寄存器$R$。 源和目的的值可以是 16 位，32 位，64 位，不支持单字节传送。汇编器可以从目标寄存器的名字判断条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个指令名字。

|     指令     | 同义名  |     传送条件     |   描述   |
| :----------: | :-----: | :--------------: | :------: |
| cmove $S,R$  |  cmovz  |        ZF        |   相等   |
| cmovne $S,R$ | cmovnz  |       ~ZF        |  不相等  |
| cmovs $S,R$  |         |        SF        |   负数   |
| cmovns $S,R$ |         |       ~SF        |  非负数  |
| cmovg $S,R$  | cmovnle | ~(SF ^ OF) & ~ZF | 有符号>  |
| cmovge $S,R$ | cmovnl  |    ~(SF ^ OF)    | 有符号>= |
| cmovl $S,R$  | cmovnge |     SF ^ OF      | 有符号<  |
| cmovle $S,R$ | cmovng  | (SF ^ OF) \| ZF  | 有符号<= |
| cmova $S,R$  | cmovnbe |    ~CF & ~ZF     | 无符号>  |
| cmovae $S,R$ | cmovnb  |       ~CF        | 无符号>= |
| cmovb $S,R$  | cmovnae |        CF        | 无符号<  |
| cmovbe $S,R$ | cmovna  |     CF \| ZF     | 无符号<= |

不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，都会对条件的两个结果求值，如果求值的过程中可能产生错误条件或者副作用，就会导致非法的行为。

条件传送不总是会提高代码的效率，如果求值需要大量的计算，就有可能不划算。

### 循环

通过条件控制和跳转实现循环。

#### do-while 循环

通用形式

```c
do
    body-statement
    while (test-expr)
```

goto 形式

```c
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
```

#### while 循环

通用形式

```c
while (test-expr)
    body-statement
```

跳转中间的翻译

```c
    goto test;
loop:
    body-statement
test:
    t = test-expr;
    if (t)
        goto loop;
```

guarded-do 翻译

```c
t = test-expr;
if (!t)
    goto done;
loop:
    body-statement
    t = test-expr;
    if (t)
        goto loop;
done;
```

#### for 循环

通用形式

```c
for (init-expr; test-expr; update-expr)
    body-statement
```

跳转到中间的策略

```c
    init-expr;
    goto test;
loop:
    body-statement;
    update-expr;
test:
    t = test-expr;
    if (t)
        goto loop;
```

guarded-do 策略

```c
    init-expr
    t = test-expr;
    if (!t)
        goto done;
loop:
    body-statement
    update-expr
    t = test-expr;
    if (t)
        goto loop;
done
```

### switch 语句

switch 语句根据一个整数索引值进行多重分支。利用跳转表，使执行开关语句的时间和开关情况的数量无关。

## 过程

过程是一个重要的抽象，它提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。然后，可以在程序中不同的地方调用这个函数。不同的编程语言中，过程的形式多样：函数(function)，方法(method)，子例程(subroutine)，处理函数(handler)。

过程 P 调用过程 Q,Q 执行后返回 P。其中包含的机制：

- **传递控制** 在进入过程 Q 的时候，程序计数器必须被设置为 Q 的代码的起始地址，然后在返回时，把程序计数器设置为 P 中调用 Q 后面那条指令的地址。
- **传递数据** P 必须能够向 Q 提供一个或多个参数，Q 必须能够向 P 返回一个值。
- **分配和释放内存** 在开始时，Q 可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。

### 运行时栈

C 语言过程调用机制的一个关键特性是使用了栈数据结构提供的后进先出的内存管理原则。

程序用栈来管理它的过程所需要的存储空间，栈和程序寄存器存放着传递控制和数据需要的信息和分配内存所需要的信息。当 P 调用 Q 时，控制和数据添加到栈尾。当 P 返回时，这些信息会释放掉。

当 x86-64 过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间。这个空间被称为过程的*栈帧*。

当前正在执行的过程的帧总是在栈顶。

当过程 P 调用过程 Q 时，会把返回地址压入栈中，指明当 Q 返回时，要从 P 程序的哪个位置继续执行。把这个返回地址也当作 P 的栈帧的一部分，因为存放的是 P 相关的状态。

Q 的代码会扩展当前栈的边界，分配它的栈帧所需的空间。在这个空间中，它可以保存寄存器的值，分配局部变量空间，为它调用的过程设置参数。

通过寄存器，过程 P 可以传递最多 6 个整数值（也就是指针和整数），但是如果 Q 需要更多的参数，P 可以在调用 Q 之前在自己的栈帧里存储好这些参数。

x86-64 过程只分配自己所需要的栈帧部分。实际上，许多函数甚至根本不需要栈帧。

### 转移控制

将控制从函数 P 转移到函数 Q 只需要简单地把程序计数器（PC）设置为 Q 的代码的起始位置。从 Q 返回的时候，处理器必须记录好它继续执行 P 的代码位置。X86-64 中，这个信息用指令 call Q 调用 Q 记录。该指令会把地址 A 压入栈中，并将 PC 设置为 Q 的起始位置。压入的地址 A 被称为返回地址，是紧跟在 call 指令后的那条指令的地址。

|      指令       |       描述       |
| :-------------: | :--------------: |
|  call $Label$   |     过程调用     |
| call $*Operand$ |     过程调用     |
|       ret       | 从过程调用中返回 |

call 指令有一个目标，指明被调用过程起始的指令地址。调用可以是直接的，也可以是间接的。

### 数据传送

x86-64 中，大部分过程间的数据传输是通过寄存器实现的。通过寄存器最多可以传递 6 个整形（整数和指针）参数。

寄存器的使用是有特殊顺序的，寄存器使用的名字取决于要传递的数据类型的大小。会根据参数在参数列表中的顺序为它们分配寄存器。

| 操作数大小(位) | 参数数量 |      |      |      |      |      |
| :------------: | :------: | :--: | :--: | :--: | :--: | :--: |
|                |    1     |  2   |  3   |  4   |  5   |  6   |
|       64       |   %rdi   | %rsi | %rdx | %rcx | %r8  | %r9  |
|       32       |   %edi   | %esi | %edx | %ecx | %r8d | %r9d |
|       16       |   %di    | %si  | %dx  | %cx  | %r8w | %r9w |
|       8        |   %dil   | %sil | %dl  | %cl  | %r8b | %r9b |

如果一个函数有大于6个整形参数，超过6个的部分就要通过栈来传递，参数7位于栈顶。通过栈传递参数时，所有的数据大小都向8的倍数对齐。参数到位以后，程序就可以执行call指令将控制转移给被调用过程了。

### 栈上的局部存储

局部数据必须存放在内存中的常见情况：

- 寄存器不足够存放所有的本地数据
- 对一个局部变量使用地址运算符‘&’
- 某些局部变量是数组或结构

### 寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源，需要确保当一个过程调用另一个过程时，被调用者不会覆盖调用者稍后会使用的寄存器值。x86-64采用了一组统一的寄存器使用惯例，所有的过程都必须遵循。

寄存器%rbx、%rbp和%r12~%r15被划分为*被调用者保存*寄存器。当过程P调用过程Q时，Q必须保存这些寄存器的值，保证它们的值在Q返回到P时与Q被调用时是一样的。怎么保存？过程Q要么不改变寄存器的的值，要么就是把原始值压入栈中，然后在返回前从栈中弹出这个值。压入寄存器的值会在栈帧中创建标号为“保存的寄存器”的一部分。

所有其他的寄存器，除了栈指针%rsp，都分类为*调用者保存寄存器*，这意味着任何函数都能修改它们。过程P在某个此类寄存器中有局部数据，然后调用过程Q。Q可以随意修改这个寄存器，如果P需要这个数据，那么保存好它就是P的责任。

### 递归过程

寄存器和栈的使用惯例使得过程可以递归的调用自身。每个过程调用在栈中都有它自己的私有空间，因此多个未完成调用的局部变量不会相互影响。

递归调用一个函数本身与调用其他函数时一样的。栈规则提供了一种机制，每次函数调用都有它自己私有的状态信息（保存的返回位置和被调用者保存寄存器的值）存储空间。如果需要它还可以提供局部变量的存储。栈的分配和释放很自然地与函数调用返回的顺序匹配。

## 数组分配和访问

数组是C语言将标量数据聚集成更大数据类型的一种方式。C语言可以产生数组的指针，并对这些指针进行运算。在机器代码中，这些指针会被翻译成地址计算。

### 基本原则

对于声明`T A[N]`:

假设它的起始位置为$x_a$，L代表T的大小（字节）。则它在内存中分配了一个$L\bullet N$字节的连续区域。同时引入了标识符A，可以用A来表示数组开头的指针，这个指针的值是$x_a$，数组元素i会被存放在地址$x_a+L\bullet i$。

### 指针运算

C语言允许对指针进行运算，计算出来的值会根据该指针引用的数据类型的大小进行伸缩。如果p是一个指向类型T的数据的指针，p的值为$x_p$，那么表达式$p+i$的值为$x_p + L \bullet i$。

### 嵌套的数组

对于声明`T D[R][C]`:

它的数组元素`D[i][j]`的内存地址为

$$ \&D[i][j] = x_d + L(C \bullet i + j)$$

### 定长数组

编译器会对定长多维数组进行优化。

### 变长数组

C99允许数组的维度是表达式，这个表达式可以在数组被分配的时候才计算出来。表达式可以是一个局部变量，也可以是一个函数的参数。例如：

```c
int var_ele(long n, int A[n][n], long i, long j) {
    return A[i][j];
}
```

```armasm
@ n in %rdi, A in %rsi, i in %rdx, j in %rcx
var_ele:
    imulq   %rdx, %rdi
    leaq    ($rsi,%rdi,4), %rax
    movl    (%rax,%rcx,4), %eqx
    ret
```

参数n必须在参数`A[n][n]`之前，这样函数就可以在遇到这个数组的时候计算出数组的维度。

相较于定长数组的地址计算，它的不同点在于：

- 由于增加了参数n，寄存器的使用变化了。
- 用乘法指令来计算$n \bullet i$，而不是leaq指令来计算。

在一个循环中引用变长数组时，编译器常常利用访问模式的规律性来优化索引的计算。

## 异质的数据结构

C语言有两种将不同类型的对象组合到一起创建数据类型的机制：

- 结构：用关键字`struct`声明，将多个对象集合到一个单位中
- 联合：用关键字`union`声明，允许用不同的类型来引用一个对象。

### 结构

类似于数组的实现，结构的所有组件部分都存放在内存中一段连续的区域内，而指向结构的指针就是结构第一个字节的地址。编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的偏移，从而产生对结构元素的引用。

要产生一个指向结构内部对象的指针，只需将结构的地址加上该字段的偏移量。

结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

### 联合

联合允许以多种类型来引用一个对象，它用不同的字段来引用相同的内存块。一个联合总的大小等于它最大字段的大小

### 数据对齐

## 控制与数据的结合
