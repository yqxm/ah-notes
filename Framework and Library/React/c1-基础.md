# 基础

## JSX

React认为UI逻辑和渲染逻辑应该是一起的。JSX可以达成这个目标，将标记和JS放在一起组成component，实现关注点分离。

### JSX中插值

在大括号中可以放入任意Javascript表达式。

可以使用引号或包裹在大括号中的JS表达式来指定属性（只选择一种使用）

```javascript
const name = "huhu"

const e1 = <h1>Hello, {name}</h1>;
const e2 = <img tabindex="0" />
const e3 = <img src={user.avatarUrl}>
```

## 元素渲染

在根DOM节点内的内容全部由ReactDOM管理。把元素传给ReactDOM，即`ReactDOM.render()`函数，这样就可以将元素渲染到根节点中。

React元素是不可更改的，它代表某一时刻元素的状态，要更新只有重新创建元素，然后再传入到ReactDOM中。

React会将元素和它之前的状态进行比较，然后只更新需要更新的部分。

## 组件与props

```javascript
// 函数式组件
function Welcome(props) {
    return <h1>Hello, {props.name}</h1>
}

// class组件
class Welcome extends React.Componet {
    render() {
        return <h1>Hello, {this.props.name}</h1>
    }
}

```

组件也可以作为元素被渲染。

组件在其输出中可以引用其他组件。

组件设计应该只关注它自身，不关心使用它的上下文。

props是只读的，不能被更改。

## state和生命周期

state就是状态

class类型的组件就像对象。对象有状态，有生命周期。

`componentDidMount()`方法执行组件第一次被渲染的时候会做的事。`componentWillUnmount()`方法执行不需要这个组件的时候会做的事。

### state的正确使用

- 不直接修改state
- state的更新是异步的
- state的更新会被合并

props和state的更新是异步的，所以不要依赖它们的值来更新下一个状态。`setState((state, props) => {})`来避免直接修改state无法更新的问题。第一个参数为上一个状态，第二个参数为此次更新要用的props

### 数据是向下流动的

组件只能向它之下的组件传递数据。

“如果你把一个以组件构成的树想象成一个 props 的数据瀑布的话，那么每一个组件的 state 就像是在任意一点上给瀑布增加额外的水源，但是它只能向下流动。”

## 事件处理

- React事件采用小驼峰式
- Jsx要求传入函数作为事件处理函数，而不是字符串

阻止事件的默认行为需要显式的调用`preventDefault`

事件监听可以在创建组件的时候将函数绑定。

```javascript
constructor(props) {
        super(props);
        this.state = {isToggleOn: true}
        this.handleClick = this.handleClick.bind(this) //绑定
    }
```

class的方法默认不会绑定this，如果直接在Jsx中用this使用方法的话会显示`undefined`

### 向事件传递参数

```javascript
// 事件显式的传递
<button onClick={(e) => this.deleteRow(id, e)}>Delete Row</button>
// 事件隐式的传递
<button onClick={this.deleteRow.bind(this, id)}>Delete Row</button>
```

## 条件渲染

使用Js中的`if`或者`条件运算符`创建元素表现当前的状态。React根据它们来更新UI。

通过花括号可以在JSX中嵌入表达式，然后使用`&&`运算符或者三目运算符来控制UI。

### 阻止组件渲染

`render`方法返回`null`。

## 列表&key

{}中嵌入Js表达式以渲染多个组件。当这些组件以列表的形式存在的时候，需要设定key。key帮助React识别哪些组件发生了改变，key在列表中应该是一个独一无二的字符串。

key应该放在就近的数组上下文中

key在其兄弟节点之间应该是唯一的，但不需要是全局唯一。两个不同的数组可以使用相同的key。

## 表单

React里表单元素通常会保持一些内部的state。

### 受控组件

渲染表单的React组件还控制着用户输入过程中表单发生的操作，这样的组件被称为受控组件。

对受控组件来说，输入的值始终由React的state驱动。

### 处理多个输入

当需要处理多个input元素时，我们可以给每个元素添加name属性，并让处理函数根据event.target.name的值选择要执行的操作。

### 受控输入空值

在受控组件上指定 value 的 prop 会阻止用户更改输入。如果你指定了 value，但输入仍可编辑，则可能是你意外地将 value 设置为 undefined 或 null

## 状态提升

多个组件需要反映相同的变化数据，这时我们建议将共享状态提升到最近的共同父组件中去。

在React应用中，任何可变数据应当只有一个相对应的唯一“数据源”。通常，state都是首先添加到需要渲染数据的组件中去。然后，如果其他组件也需要这个state，那么可以将它提升到这些组件的最近共同父组件中。

如果某些数据可以由props或state推导得出，那么它就不应该存在与state中。

## 组合与继承

有些组件无法提前知晓它们子组件的具体内容，建议这些组件使用一个特殊的 children prop 来将它们的子组件传递到渲染结果中

有些时候，我们会把一些组件看作是其他组件的特殊实例。特殊实例可以通过 props 定制实现。