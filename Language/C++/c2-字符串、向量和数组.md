# 字符串、向量和数组

## using

```cpp
using namespace::name;

name exp;
```

每个名字都需要独立的 using 声明，using 声明只能引入命名空间中的一个成员。

头文件中不应该包含 using 声明：头文件的内容会拷贝到所有引用它的文件中，如果头文件里有某个 using 声明，那么每个使用了该头文件的文件都会有这个声明，有可能会产生名字冲突。

## string

### 初始化

### 对象上的操作

size_type 是 size 函数返回值类型。它是一个无符号类型的值并且能够存放下任何 string 对象的大小。 注意不要和有符号的数混用！

### 字面值和 string 相加

运算符两侧的运算对象至少有一个是 string。

C++中的字符串字面值并不是标准库类型 string 的对象。

## vector

vector 是一个类模板，模板本身不是类或函数。编译器根据模板创建类或函数的过程称为实例化。

vetor 能容纳绝大多数类型的对象作为其元素，但是因为引用不是对象，所以不存在包含引用的 vector。

## 迭代器

迭代器提供了对对象的间接访问，迭代器可以访问某个元素，也能从一个元素移动到另一个元素。有效的迭代器或者指向某个元素，或者指向容器中尾元素的下一个位置，其他情况都属于无效。

### 迭代器使用

有迭代器的类型同时拥有返回迭代器的成员。比如 begin 和 end。begin 成员负责返回指向第一个元素的迭代器，end 成员负责返回指向容器“尾元素的下一个位置”的迭代器，即容器中的一个本不存在的“尾后”元素。当容器为空时，begin 和 end 返回的是同一个迭代器。

| 运算符       | 含义                                                           |
| ------------ | -------------------------------------------------------------- |
| \*iter       | 返回迭代器 iter 所指元素的引用                                 |
| iter->mem    | 解引用 iter 并获取该元素的名为 mem 的成员，等价于`(*iter).mem` |
| ++iter       | 令 iter 指向容器的下一个元素                                   |
| --iter       | 令 iter 指向容器的上一个元素                                   |
| iter1==iter2 | 判断容器是否相等                                               |
| iter1!=iter2 | 判断容器是否不等                                               |

一般情况下，不需要迭代器的精确类型。拥有迭代器的标准库类型使用 iterator 和 const_iterator 来表示迭代器类型。

#### begin 和 end

```cpp
vector<int> v;
const vector<int> cv;
auto it1 = v.begin();       //it1的类型是vector<int>::iterator
auto it2 = cv.begin();      //it2的类型是vector<int>::const_iterator

auto it3 = v.cbegin();      //it3的类型是vector<int>::const_iterator
```

为了便于得到 const_iterator 类型的返回值，C++11 引入了 cbegin 和 cend。不管 vector 对象本身是否是常量，返回值都是 const_iterator。

箭头运算符(->)把解引用和成员访问两个操作结合

#### 迭代器失效

任何一种改变 vector 对象容量的操作都会使该 vector 对象的迭代器失效。

## 数组

数组是一种复合类型。数组声明形如 a[d]，其中 a 是数组的名字，d 是数组的维度。维度说明数组中元素的个数，编译的时候维度应该是已知的。所以，维度必须是一个常量表达式。

不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。

### 字符数组

字符数组可以使用字符串字面值对其进行初始化，这种方式初始化时需要注意字符串字面值的结尾初还有一个空字符。

### 数组声明

数组本身是对象，允许定义数组的指针及数组的引用。

```cpp
int *ptrs[10];              // ptrs是一个包含10个整形指针的数组
int &refs[10] = /* ? */;    // 错误！不存在引用的数组
int (*Parray)[10] = &arr;   // Parray指向一个包含10个整形元素的数组
int (&arrRef)[10] = arr;    // arrRef是一个包含10个整形元素的数组的引用
```

从数组的名字开始按照有内向外的顺序理解数组的声明。

### 数组访问

数组下标通常将其定义为 size_t 类型。size_t 是一种与机器相关的无符号类型，能够表示内存中任意对象的大小，定义在 cstddef 头文件中。

### 指针和数组

在很多用到数组名字的地方，编译器会自动将其替换为一个数组首元素的指针

### 指针也是迭代器

迭代器支持的运算，数组的指针全都支持。

C++11 引入了 begin 和 end 函数。这两个函数和容器中的两个同名成员功能类似，不过因为数组不是类类型，所以这两个函数不是成员函数。

```cpp
int ia[] = {0,1,2,3};
int *beg = begin(ia);
int *end = end(ia);
```

数组的下标运算符所用的索引值不是无符号类型。这一点与 vector 和 string 不一样。

### C 风格字符串

在 C++程序中最好还是不要使用 C 风格字符串。

## 多维数组

多维数组是数组的数组。通常使用两个维度来定义它：一个维度表示数组本身大小，另一个维度表示其元素大小。

使用类型别名简化多维数组的指针。
