# 绪

## 复杂度度量

### 时间复杂度

从保守估计的角度出发，在规模为n的所有输入中选择执行时间最长者作为$T(n)$，并以$T(n)$度量该算法的时间复杂度。

### 渐进复杂度

#### 大$O$记号

若存在正的常数$c$和函数$f(n)$,使得对任何$n>>2$都有
$$T(n)\leq c\bullet f(n)$$

则可认为在$n$足够大后，$f(n)$给出了$T(n)$增长速度的一个渐进上界。记为:

$$T(n) = O(f(n))$$

大$O$具有以下性质

- 对于任一常数$c>0$，有$O(f(n)) = O(c\bullet f(n))$
- 对于任意常数$a>b>0$，有$O(n^a+n^b)=O(n^a)$

第一个性质意味着，函数各项正的常系数可以忽略并等同于1。后一性质则意味着，多项式中的低次项均可忽略

#### 基本操作

将$T(n)$定义为算法所执行基本操作的总次数

#### 大$\Omega$记号

若存在正的常数$c$和函数$g(n)$,使得对任何$n>>2$都有
$$T(n)\geq c\bullet g(n)$$

则可认为在$n$足够大后，$g(n)$给出了$T(n)$增长速度的一个渐进下界。记为:

$$T(n) = \Omega(g(n))$$

#### 大$\Theta$记号

若存在正的常数$c1<c2$和函数$h(n)$,使得对任何$n>>2$都有
$$c1\bullet h(n)\leq T(n) \leq c2\bullet h(n)$$

则可认为在$n$足够大后，$h(n)$给出了$T(n)$的一个确界。记为:

$$T(n) = \Theta(h(n))$$

对于规模为$n$的任何输入，算法的运行时间$T(n)$都与$\Theta h(n)$同阶。

### 空间复杂度

空间复杂度通常并不计入原始输入本身所占用的空间。其它（转储，中转，索引，映射，缓冲等）各个方面所消耗的空间，都应计入。

就渐进复杂度的意义而言，任一算法的任何一次运行过程中所消耗的存储空间，都不会多于其间所执行基本操作的累计次数。时间复杂度本身就是空间复杂度的一个天然上界。

## 复杂度分析

- 常数$O(1)$：仅含一次或常数次基本操作的算法
- 对数$O(logn)$
- 线性$O(n)$
- 多项式$O(polynomial(n))$
- 指数$O(2^n)$

算法复杂度的界定，都是相对于问题的输入规模而言的。

## 递归

### 线性递归

算法可能朝着更深一层进行自我调用，且每一递归实例对自身的调用至多一次。

线性递归的模式，往往对应减而治之的算法策略：递归每深入一层，待求解问题的规模就缩减一个常数。

### 递归分析

- 递归跟踪
- 递推方程

### 递归模式

- 多递归基
- 多向递归

### 递归消除

- 尾递归

### 二分递归

分而治之：将问题分解为若干规模更小的子问题，再通过递归机制分别求解。

要使分治策略真正有效，必须保证子问题之间相互独立，各子问题可独立求解。

优化策略：借助一定量的辅助空间，在各子问题求解之后，及时记录下其对应的解答。

- 制表：检验子问题是否已计算，然后通过直接调阅记录获得解答，避免重复计算
- 动态规划：从递归基出发，自底而上递推得出子问题的解。