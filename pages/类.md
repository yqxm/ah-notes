- **成员函数**
	- **声明和定义**
		- 成员函数必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。
			- 当在类的外部定义成员函数时成员函数的定义必须与它的声明匹配。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定`const`属性。
			- 类外部定义的成员的名字必须包含它所属的类名。
	- **访问数据**
		- 成员函数通过一个名为`this`的隐式参数来访问调用它的对象。当调用一个成员函数时，`this`被请求该函数的对象地址初始化。
		- 在成员函数内部，可以直接调用该函数的对象的成员。任何对类成员的直接访问都被看作`this`的隐式引用。
		- 返回`*this`来返回调用函数的对象。
	- **`const`成员函数**
		- `const`的作用时修改隐式`this`指针的类型。把它的类型改变为`const Sales_data *const`。
		- 默认情况下，`this`的类型是指向类 类型非常量 版本的常量指针。比如它的类型是`Sales_data *const`。这意味着`this`不能绑定到一个常量对象上，因为常量对象的地址只能由指向常量的指针存放。
		- #+BEGIN_NOTE
		  常量对象，以及常量对象的引用或指针都只能调用常量成员函数。
		  #+END_NOTE
- **类相关的非成员函数**
	- **声明和定义**
		- 函数的声明和定义分开，如果函数在概念上属于类但不定义在类中，则它一般应与类声明(而非定义)在同一个头文件内。
- **构造函数**
	- 类通过一个或几个特殊的成员函数来控制其对象的初始化过程，这些函数就是构造函数。只要类的对象被创建，就会执行构造函数。
	- **特点**
		- 构造函数名字和类名相同
		- 构造函数没有返回类型
		- 类似于重载，不同的构造函数必须在参数数量或参数类型上有所区别。
	- **默认构造函数**
		- 默认构造函数控制默认初始化过程，它无须任何实参，由编译器创建。
			- 初始化规则:
				- 如果存在类内的初始值，用它来初始化成员
				- 否则默认初始化该成员
		- 某些类不能依赖于合成的默认构造函数的原因:
			- 编译器只有在发现类不包含任何构造函数的情况下才会生成一个默认的构造函数。
			- 合成的默认构造函数可能执行错误的操作。因为内置类型或复合类型的对象被默认初始化可能会得到未定义的值。
			- 编译器无法为某些类合成默认的构造函数。比如，类中的某个其他类型的成员没有默认构造函数，编译器无法将它初始化，就无法合成默认构造函数。
		- 如果需要默认的行为，可以通过在参数列表后面加`= default`来要求编译器生成构造函数。
	-