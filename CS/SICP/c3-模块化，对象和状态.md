# 模块化，对象和状态

## 对象

好处：

- 更方便的进行模块化设计

代价：

- 计算的结果和状态相关，不再是一个纯粹的函数
- 过程还是相同的吗？

## 环境模型

环境是框架的序列。每一个框架有一张表，绑定变量和变量的值。框架还有一个指向外围环境的指针。

如何计算：

- 计算组合式的子表达式
- 将运算符子表达式的值应用到操作数子表达式

### 过程创建

在环境模型中，过程由代码和指向环境的指针组成。过程只能通过计算lambda表达式创建。形如下图：

![img](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/ch3-Z-G-3.gif)

### 过程计算

要应用参数到过程，需要创建一个新环境绑定参数和参数值，这个环境的外围环境就是过程指向的环境。然后在新环境进行计算。形如下图：

![img](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/ch3-Z-G-4.gif)

### 环境作为存储变量的仓库

环境维持了对象的状态，即变量。通过`set！`对环境进行更改，也就改变了对象的状态。

```scheme
(define (make-withdraw balance)
  (lambda (amount)
    (if (>= balance amount)
        (begin (set! balance (- balance amount)) balance)
        "Insufficient funds")))

(define W1 (make-withdraw 100))

(W1 50)
```

1. 创建了`make-withdraw`过程对象，有参数balance和过程体lambda，指向全局环境
2. 创建W1绑定到过程`(make-withdraw 100)`,`(make-withdraw 100)`创建新环境E1，绑定100到变量`balance`
3. `(W1 50)`创建新环境E2，指向E1，绑定50到变量`amount`。展开计算后在`set!`时将balance进行了更改。

最后结果如下图：

![img](https://mitpress.mit.edu/sites/default/files/sicp/full-text/book/ch3-Z-G-9.gif)

### 内部定义

计算过程的时候会创建新环境， 内部定义会绑定到新环境中，所以内部定义的变量名不会和外部定义冲突。同时内部定义的过程可以使用外围环境的参数名，这是因为当前过程所在的环境从属于外围过程的环境。

## 并发：本质是一个时间问题

a
