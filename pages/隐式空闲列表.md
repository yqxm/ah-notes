- ### 堆块
	- 任何实际的分配器都需要一些数据结构，允许它来区别边界，以及区别已分配块和空闲块。大多数分配器将这些信息嵌入块本身。如图:
		- ![image.png](../assets/image_1663653180381_0.png)
		- 在这种情况下，一个块是由一个字的头部、有效载荷，以及一些额外的填充组成。头部编码了这个块的大小(包括头部和所有的填充)，以及这个块是已分配的还是空闲的。
			- 假设双字对齐，那么块的大小总是8的倍数，那么块大小的最低3位总是0。因此，描述块大小只需要29个高位，剩余的3位来编码其他信息。
				- 假设有一个已分配的块大小为24(0x18)字节，那它的头部是`0x00000018 | 0x1 = 0x00000019`
				- 假设有一个空闲块的大小为40(0x28)字节，那它的头部是`0x00000028 | 0x 0 = 0x00000028`
	- 头部后面是应用调用`malloc`时请求的有效载荷。有效载荷后面是一片不使用的填充块，其大小是任意的。填充原因可能是为了对付外部碎片或者为了满足对齐要求。
- ### 用隐式空闲列表组织堆
	- ![image.png](../assets/image_1663657127003_0.png)
	- 空闲块通过头部中的大小字段隐含地连接着的。分配器可以通过遍历堆中所有的块，从而间接遍历整个空闲块的集合。
		- **注意**，我们需要某种特殊标记的结束块，示例中就是一个已设置了分配位而大小为0的终止头部(terminating header)(设置已分配位简化了空闲块的合并)
	- 使用隐式空闲列表的优点是简单，缺点是任何操作的开销。例如放置分配的块需要对空闲列表进行搜索，该搜索与已分配的块和空闲块的总数呈线性关系。
- ### 放置已分配的块
	- 当一个应用请求一个$k$字节的块时，分配器搜索空闲列表，查找一个足够大可以放置请求块的空闲块。分配器执行这种搜索的方式是由放置策略(placement policy)确定的。一些常见的策略是**首次适配**(first fit)、**下一次适配**(next fit)和**最佳适配**(best fit)。
	- #### 首次适配
		- 从头开始搜索空闲链表，选择一个合适的空闲块。
		- **优点**: 趋向于将大的空闲块保留在链表的后面。
		- **缺点**: 趋向于在靠近链表起始处留下小空闲块的碎片，增加了对较大块的搜索时间。
	- #### 下一次适配
		- 从上一次查询结束的地方开始搜索，选择一个合适的空闲块。
		- **优点**: 比首次适配更快，尤其是链表中的小碎片较多时。
		- **缺点**: 内存利用率比首次适配低的多。
	- #### 最佳适配
		- 检查每个空闲块，选择是个所需请求大小的最小空闲块。
		- **优点**: 内存利用率高。
		- **缺点**: 在简单的空闲列表组织结构中，使用最佳适配的缺点是它要求对堆进行彻底的搜索。
- ### 分割空闲块
	- 一旦一个分配器找到一个匹配的空闲块，它就必须做另一个决策，分配空闲块多少空间。可以使用整个空闲块，但会产生内部碎片。如果放置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。
	- 如果匹配不太好，分配器通常会选择将这个空闲块分割为两部分，分配块和新的空闲块。
	- ![image.png](../assets/image_1663662147280_0.png)
- ### 获取额外的堆内存
	- 如果分配器不能为请求块找到合适的空闲块，有两个选择。
		- 1. 合并那些在内存中物理相邻的空闲块来创建一些更大的空闲块。
		- 2. 分配器通过调用`sbrk`函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个块插入到空闲列表中，然后将被请求的块放置在这个新的空闲块中。
- ### 合并空闲块
	-