# 信息的表示和处理

> 数字的表示？

无符号编码，有符号编码，浮点数编码。

## 信息存储

### 存储

> 最小的内存单位是什么？怎么找到它？

在大多数计算机当中，字节是最小的可寻址的内存单位，每个字节都有对应的一个地址。

> 什么是虚拟内存？

计算机将内存视为一个巨大的数组，这个数组就是虚拟内存。实际上它是由各个硬件和操作系统抽象出来的。

> 什么是虚拟地址空间？

所有地址的集合就是虚拟地址空间。

### 字长

> 什么是字长？

字长，指示了内存的最大大小。比如字长是32位或64位。32位机器的最大内存是4gb，64位机器最大内存为2的64次方个字节。

> 字长对程序的影响？

以C语言来说，基本类型的大小在不同字长的机器上是不同的。比如`char *`在32位上占用4个字节，在64位上占用8个字节。

> char的特殊之处？

它的特殊之处在于它代表的是无符号还是有符号的数据。大多数编译器把`char`当成有符号的。但它是不是有符号对程序似乎没什么影响。

> 字长对移植的影响？

字长的影响主要还是来自于编译器的不同。因为不同字长的机器的编译器对同一类型的大小上限是不同的。比如说，在32位机器上可以将`char *`赋值给`int`类型，在64位机器上就不行了。因为`char*`在32位机器上占用4个字节，在64位机器上占用8个字节。

### 对象的排列

> 对象是如何排列的？

关于对象有两个重要的原则：

1. 它在什么位置。
2.它是如何排列的。 常见的排列方式有两种，小端法和大端法。

> 什么是小端法？

小端法排列是将数据低位排在前面。比如0x123456，它的排列方式就是 56 34 12。为什么是56而不是65呢？如前所说，内存的最小单位是字节，一个字节是8位，刚好可以存放两个16进制数字。所以是56而不是65。

> 什么是大端法？

大端法排列是将数据从高位开始排列。比如0x123456，它的排列方式就是 12 34 56。

> 字节顺序什么情况下会产生问题？

字节顺序在大多数情况下都不可见。但有三种情况下它的排列顺序会显得很重要。

1. 在网络传输时，小端法机器的二进制数据传递给大端法机器时可能出现问题。解决办法是有一个中间标准，传递方将数据翻译成符合标准的数据，接收方将符合标准的数据翻译成符合本地的数据。
2. 检查机器级程序时，可能需要阅读数据的二进制表示。
3. 系统编程时，需要使用强制类型转换和联合将数据以其他类型表达出来。

### 字符串

> 字符串是如何表示的？

字符串是以'\0'为结尾的字符串数组。在以ASCII码作为字符码传输时，在任何平台都能得到相同的结果，与字大小和字符顺序无关。

### 布尔代数

> 什么是布尔代数？

以0和1建立的数学体系。包括常见的非，与，或，异或等运算。

> 什么是布尔环？

$$ (a \bigoplus b) \bigoplus a=b $$

一个和自己的异或等于0，一个数和0的异或等于自己。所以有了上面这个表达式。它可以有一些有趣的应用(我暂时还没用到)

> 位向量有什么应用？

位向量可以用于标记，用0或1表示标记的东西是否出现。

### 位级运算

> C语言中的位级运算是怎样的？

包括布尔运算的非，与，或，异或。

> 位级运算有什么应用？

位掩码是其中一个应用。使用和运算选出自己想要的集合。比如将数据与0xFF进行和运算就可以选出数据的低8位有效数字。

### 移位运算

> C语言中的移位运算是怎样的？

对于左移，丢弃最高位，右边补0。

对于右移分为算数右移和逻辑右移，两者都会丢弃最低位，不同的是算术右移最高位补最高有效位的值，逻辑右移最高位补0。

补1有什么好处呢？对于有符号数来说，算数右移并没有改变它的符号。

> 两种右移运算的使用场景？

在C语言中，对于有符号数，大部分编译器都使用算数右移，程序员也默认是算数右移。对于无符号数，默认为逻辑右移。

在Java中，明确规定 `x >> k`为算数右移。`x >>> k`为逻辑右移。

## 整数的表示

### 整数的编码方式

> 编码方式有哪些？

无符号编码和有符号编码

> 什么是无符号编码?

无符号编码是对非负数的编码。根据数据的类型，它的所有位都将用来表示数据。如果要表示的数超出了这个类型所能表示的值，截掉超出的部分。这里的截掉是指将这个数转换成二进制表示，然后切掉超出这个类型最高位的部分。

> 什么是有符号编码？

有符号数有好几种编码方式，原码，反码和补码。

补码比其他两种编码方式好的原因是它的0只有一种表达方式。每个数字都只有一种表达方式，有一一映射的特性。

但它的数据的表示范围不是对称的，最小数的绝对值比最大值的绝对值大1。原因是最高位是符号位，但它不是标记符号，当它为1时，表示2的k次方的负数，它的绝对值也就比最大的整数大1。

> 有符号数和无符号数是怎样进行转换的？

依据数字本身的二进制表示，将它表示成无符号数和有符号数。比如unsigned int的最大值为0xFFFF，表示为int时它还是0xFFFF，但是翻译为有符号数时表示-1。

> C语言中的无符号数和有符号数有什么奇特的特性？

一个条件表达式中如果包含无符号数，那么其他数也会被翻译成无符号数所以会出现。`-1 > 2U` 为真的情况。

> 无符号数怎样进行扩展？

对与无符号数，要将它扩展成更大的数据类型，只需要在高位补0就可以了。

> 有符号数怎样进行扩展？

对于有符号数，扩展时最高位补充符号位的数。这里体现了补码的便捷，如果数是正数，高位就补0，不影响数字的大小。如果数是负数，高位就补1，同样不影响原数的大小。这是因为，对于每一次高位补1，原来的高位从负变正，增加的大小刚好就等于新的最高位减去的大小。总体来看，数字的大小就没有发生变化。

> 怎样进行截断？

先转换成二进制表示，然后把超出类型所能表示的位给切掉。

### 整数运算

> 如何进行加法运算？

先将数字表示成二进制表示，然后相加，超出的部分截掉，最后得到结果

> 如何进行减法运算?

减法相当于被减数加上减数的加法逆元。一个数的加法逆元就是它的非加1。所以原式就可以转换成加法运算。

有一种特殊情况，对于补码中的最小值，它的加法逆元还是它自身。

> 如何进行乘法运算？

同样还是位级表示，然后将超出部分截掉。

> 乘以常数进行了怎样的优化？

乘法运算比加法运算，移位运算要慢很多。对于乘以常数可以通过移位和加法进行优化。

> 无符号数怎样进行2的幂的除法？

进行逻辑右移

> 有符号数怎样进行2的幂的除法?

对于大于0的数，进行算数右移，向下取整。 对于小于0的数，因为要向上取整，利用偏置量，
$$\lceil x/y \rceil = \lfloor (x+y-1)/y \rfloor$$
的性质，进行运算。

这个性质是如何得到的呢？假设$x = qy+r $ 则$(x+y-1)/y$等于$ q + (r+y-1)/y $ 若r等于0，则右式向下取整为q。若r非0，则右式向下取整得到q+1。满足需求。

## 浮点数

> IEEE 怎样表示浮点数？

IEEE 用形如

$$ V = (-1)^s * M * 2^E $$

其中V是所求的值，s代表符号位，M为小数位范围是[0,1)或者[1,2)。其中E代表阶数。

对于单精度浮点数(32位)来说，有1位表示符号，8位表示阶数，23位表示小数位。

对于双精度浮点数(64位)来说，有1位表示符号，11位表示阶数，52位表示小数位。

> IEEE 编码的情况分别是怎样的？

有三种情况：

1. 规格化的值：这种情况阶数位不全为0也不全为1。阶码值为$e-Bias$，其中Bias为$2^(k-1)-1$，k为阶码位数，则偏置量单精度就为127，双精度1023。e为无符号整数。对单精度值来说它的阶码的范围就是-126~127，对双精度来说它的阶码范围就是-1022~1023。

2. 非规格化的值: 在这种情况下阶数位全为0。阶码值为 $1-Bias$，单精度为-126，双精度为-1022。在这种情况下，默认非小数位为0。

3. 特殊值：当阶数位全为1，而小数位全为0时，表示无穷大，符号位为0表示正无穷，符号位为1表示负无穷。当阶数全为1，而小数位非0时，表示$NaN$。

> 这里的偏置量有点奇怪，这样设置偏置量有什么好处？

实现了规格化到非规格化的平滑过度。以单精度为例，忽略符号位，规格化的最小值为$1 \cdot 2^{-126} $。非规格化的最大值为小数位全为$ 0.{e_1e_2...} \cdot 2^{-126} $

> 这种编码有什么样的性质？

越靠近0越稠密，越远越稀疏。

> 为什么需要舍入？

...

> 如何舍入？

...
