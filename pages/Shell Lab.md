- **描述**
	- `shell`是一个交互的命令行解释器。命令行由空白符分隔的词组成，第一个词要么是内置命令的名字，要么是可执行文件的路径。剩下的词是命令行参数。
		- 如果第一个词是内置命令，`shell`就在当前进程立即执行这个命令。
		- 如果第一个词是可执行文件的路径，`shell`就`fork`一个子进程，在子进程的上下文中执行这个程序。由解释单个命令行而产生的子进程被统称为**作业(job)**。
- **要求**
	- `tsh`不需要支持管道`|`或者`I/O`重定向。
	- 命令行的结尾如果是`&`，则表示作业运行在后台。
	- `Ctrl-c`发送一个`SIGINT`信号给当前的前台作业和这个作业的所有后代。如果没有前台作业，则这个信号没有作用。
	- 每个作业可以通过`process ID(PID)`或者`job ID(JID)`来识别--由`tsh`赋予的正整数。`JID`在命令行的表示要加前缀`%`，如`%5`。`PID`直接用数字表示。
	- `tsh`支持以下几个内置命令
		- `quit`，直接终止`shell`的运行
		- `jobs`，列出后台作业
		- `bg <job>`，用`SIGCONT`信号重启`<job>`，然后在后台运行它。`<job>`可以是`PID`或者`JID`
		- `fg <job>`，用`SIGCONT`信号重启`<job>`，然后在前台运行它。`<job>`可以是`PID`或者`JID`。
	- `tsh`应该捕获它的所有僵尸子进程。任何作业因为一个自己未捕获的信号而终止，`tsh`应该识别这个事件并打印一条包含作业`PID`和这个信号的描述的信息。
	-
- **基础设施**
	- **`parseline`**
		- ```C
		  int parseline(const char *cmdline, char **argv);
		  ```
		-