# 整数的表示和处理

##  整数编码方式

- 无符号编码
- 有符号编码
  - 补码

### 无符号编码

公式：

$$
B2U_w(\vec x)\doteq\sum_{i=0}^{w-1}x_i2^i
$$

- $B$代表二进制表示，$U$代表无符号编码，$B2U$ 表示二进制转为无符号

- $w$ 代表位数

- $x_i$ 表示第 $i$ 位上的值

### 补码

公式：

$$
B2T_w(\vec x)\doteq-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
$$

- $T$ 代表补码编码

#### 无符号编码和补码的相互转换

##### 无符号转补码

$TMax$表示补码下的最大值
$$
U2T_w(u) = 
\begin{cases} 
u\ ,  \qquad u \leq TMax_w \\ 
u-2^w\ ,\quad u > TMax_w 
\end{cases}
$$

##### 补码转无符号

$$
T2U_w(x) = 
\begin{cases}
x\ + \ 2^w,\quad x < 0 \\
x, \quad x \geq 0
\end{cases}
$$



### 整数的运算

数学上的运算没有限制，但在计算机上的运算会有溢出,溢出的需要截掉，对剩下的位进行编码

#### 加法

##### 无符号加法

$$
x+^u_wy=
\begin{cases}
x+y,\quad x+y<2^w \\
x+y -2^w, \quad 2^w \leq x+y < 2^{w+1}
\end{cases}
$$

##### 补码加法

$$
x+^t_wy = 
\begin{cases} 
x+y-2^w, \quad 2^{w-1} \leq x+y \\
x+y, \quad -2^{w-1} \leq x+y \leq 2^{w-1} \\
x+y + 2^w, \quad x < -2^{w-1}
\end{cases}
$$

##### 补码的非

$$
-^t_wx=
\begin{cases}
Tmin, \quad x=Tmin_w \\
-x, \quad x > Tmin_w
\end{cases}
$$

补码中一个数和它的非相加等于0。观察发现 $Tmin$ 的非就是它本身，其他数 $x$ 的非为 $-x$

#### 乘法

##### 无符号乘法

$$
x *^u_wy=(x \cdot y)\ mod \ 2^w
$$

##### 补码乘法

补码乘法和无符号乘法在位级上是一样的。所以可以以无符号的形式计算，再将结果转为补码。
$$
x *^t_wy = U2T_w((x\cdot y)\ mod \ 2^w)
$$
在大多数机器上整数乘法指令都相当慢。所以编译器对乘法进行了优化，用移位和加法运算的组合来代替常数因子的乘法。比如 $x*14$就可以重写为 $(x<<3)+(x<<2)+(x<<1)$。不过这种方法不能推广到除法。

#### 除法

##### 除以2的幂的优化

整数除法需要舍入到0。对无符号编码来说直接进行逻辑右移就行，而对补码来说需要使用算数右移来保证符号位，使用偏置量来保证向0舍入。

当$x<0$时
$$
(x+(1<<k)-1)>>k
$$
产生向上舍入的值。

这里利用了下面这个属性$x/y$的向上舍入**等于** $(x+y-1)/y$的向下舍入。理解这个属性可以假设$x = qy + r$。当$r = 0$时，结果为$q$。当$r > 0$时，结果为$q+1$。

