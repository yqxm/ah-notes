# 程序的机器级表示(x86-64)

## 程序编码

```bash
linux> gcc -Og -o p p1.c p2.c
```

编译选项`-Og`告诉编译器不进行优化，生成符合原始`C`结构的机器级代码。

### 机器级代码

可见的处理器状态：

- 程序计数器：给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件：包含 16 个命名的位置，分别存储 64 位的值。
- 条件码寄存器：保存最近的算数或逻辑指令的状态信息。实现控制或数据流中的条件变化
- 一个向量寄存器可以存储一个或多个整数或浮点数值。

一条机器指令只执行一个基本操作。

选项`-c`编译并汇编代码

```bash
linux> gcc -Og -c  mstore.c
```

使用`Objdump -d`来进行反汇编

```bash
linux> objdump -d mstore.o
```

机器代码和它的反汇编的一些特性：

- x86-64 指令的长度从 1-15 不等。越不常用的指令越长。
- 设计指令代码的格式是：从某个给定位置开始，可以将字节唯一的解释成机器指令
- 反汇编器根据机器代码文件中的字节序列来确定汇编代码。
- 反汇编器使用的指令命名规则和 GCC 生成的汇编代码有细微的差别

## 数据格式

Intel 用"字"代表 16 位数据类型。32 位为双字，64 位为四字

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小(字节) |
| :----: | :------------: | :----------: | :--------: |
|  char  |      字节      |      b       |     1      |
| short  |       字       |      w       |     2      |
|  int   |      双字      |      l       |     4      |
|  long  |      四字      |      q       |     8      |
| char\* |      四字      |      q       |     8      |
| float  |     单精度     |      s       |     4      |
| double |     双精度     |      l       |     8      |

大多数 gcc 生成的汇编代码都有一个后缀，表明操作的数据大小。

## 访问信息

一个 x86-64cpu 包含一组 16 个存储 64 位值的**通用目的寄存器**。这些寄存器用来存储整数和指针。

指令可以对寄存器的低位字节进行操作。操作 1 个字节，2 个字节，4 个字节或 8 个字节。操作可能对高位字节有影响。

不同的寄存器扮演不同的角色。

### 操作数指示符

三种类型

- 立即数：用来表示常数值
- 寄存器：用来表示寄存器的内容，用符号$r_a$表示任意寄存器 a,$R[r_a]$表示它的值
- 内存引用：根据计算出来的地址访问内存位置。用$M_b[Addr]$来表示在内存$Addr$开始的$b$个字节值的引用

内存引用的寻址模式： $Imm(r_b, r_i, s)$是最常用的形式。它的有效地址为$R[r_b]+R[r_i]*s$。

### 数据传送指令

#### MOV 类

源操作数制定为一个立即数，存储在寄存器或者内存中。目的操作数制定为一个位置，要么是寄存器，要么是内存地址。x86-64 规定源操作数和目的操作数不能都指向内存。

`mov`指令后可以跟`b`、`w`、`l`、`q`。分别表示移动的是字节，字，双字，四字。

大多数情况下，`mov`只会改变对应长度的数据。但例外情况是，当`movl`指令的目的是寄存器时，寄存器的高位 4 字节会设置为 0。原因是 x86-64 的惯例，任何为 32 位寄存器生成值的操作都会把该寄存器的高 32 位设置为 0。

##### movabsq

常规的`movq`只能以表示为 32 位补码的立即数作为源操作数，然后把这个值符号扩展到 64 位存储到目标位置。而`movabsq`能够以任意 64 位立即数作为源操作数，并且只能以寄存器作为目的。

#### MOVZ 和 MOVS

这两类指令以内存或寄存器作为源，以寄存器作为目的，并且将较小的源传送到较大的目的。`movz`将目的的高位填充为 0，`movs`根据源的最高位进行符号扩展。

例子：

- `movzbw`：将做了零扩展的字节传送到字
- `movsbw`：将做了符号扩展的字节传送到字

理论上应该有`movzlq`，但可以通过`movl`实现，所以没有`movzlq`。

### 压入和弹出栈操作

push 操作将数据压入栈中。pop 操作将数据从栈中弹出。都只有一个操作数

栈遵循后进先出的原则。出的位置被称为“栈顶”。

在 x86-64 中，栈向下增长。“栈顶”在最低位，栈指针`%rsp`指向栈顶的位置。

将一个四字值压入栈中，栈指针减 8，然后将值写入新的栈顶地址

## 算数和逻辑操作

### 加载有效地址

`leaq`指令将有效地址写入到目的操作数。目的操作数必须为寄存器

第一个操作数的形式是内存引用，这样它就可以进行一些简单的计算。

### 一元操作

`INC`、`DEC`、`NEG`、`NOT`是一元操作。操作数既是源也是目的，操作数为寄存器或者内存位置。

`incq(%rsp)`会使栈顶的 8 字节元素加 1。

### 二元操作

`ADD`、`SUB`、`IMUL`、`XOR`、`OR`、`AND`是二元操作。第二个操作数既是源也是目的。

第一个操作数可以是寄存器，立即数或者内存地址。第二个操作数可以是寄存器或者内存地址。当第二个操作数是内存地址时，数据从内存读出，计算后在存储到内存中。

### 移位操作

`SAL`、`SHL`、`SAR`、`SHR`是移位操作。

第一个数给出移位量，可以是立即数，或者在单字节寄存器`%c1`中。第二个数给出要移位的数。

A 代表算数移位，H 代表逻辑移位。

理论上移位量可以达到$2^8-1$,但在 x86-64 中，移位量由`%cl`寄存器的低$m$决定，其中$2^m=w$。$w$代表要操作的数据值的位数。

### 特殊的算术操作

`imulq`有两种形式

- 双操作数：从两个 64 位操作数产生一个 64 位乘积
- 单操作数：计算两个 64 位补码值的全 128 位乘积。

`mulq`计算两个 64 位无符号值的全 128 位乘积。和单操作数时的`imulq`一样，要求一个参数必须存放在寄存器`%rax`中，另一个以源操作数给出。然后将乘积存放在`%rdx`（高 64 位）和`%rax`（低 64 位）中。

汇编器根据`imulq`的操作数来判断执行哪种操作。

除法和取模操作由单操作数`idivq`，`divq`来提供。将寄存器`%rdx`存储高 64 位，`%rax`来存储低 64 位作为被除数。除数由指令的操作数提供。商保存在`%rax`中，余数保存在`%rdx`中。

`cqto`指令没有操作数，它隐含读出`%rax`的符号位，并复制到`%rdx`的所有位

## 控制

### 条件码

除了整数寄存器，CPU 还维护了一组**单个位**的条件码寄存器，用来描述最近的算术或逻辑操作的属性。

最常用的条件码：

- CF：进位标志
- ZF：零标志
- SF：符号标志。最近的操作结果为负数
- OF：溢出标志

`leaq`指令不改变任何条件码，因为它是进行地址计算的。除它以外，之前算术逻辑操作下的指令都会设置条件码。对于逻辑操作，例如`XOR`会将进位和溢出操作设置为 0。对于移位操作，进位标志会设置成最后一个被移出的位，溢出标志设置为 0。`INC`和`DEC`会设置溢出和零标志，但不改变进位标志。

`CMP`和`TEST`只改变条件码而不改变任何其他寄存器。

`CMP`行为和`SUB`一样。如果操作数相等，ZF(零标志)设置为 1。其他标志可以判断两个数的大小

`TEST`行为和`AND`一样。典型的应用是，两个操作数相等，判断这个操作数是负数，0 还是正数。或者其中一个数为掩码，指示哪些位应该被测试。

|    指令    |  基于   |   描述   |
| :--------: | :-----: | :------: |
| CMP S1,S2  | S2 - S1 |   比较   |
|    cmpb    |         | 比较字节 |
|    cmpw    |         |  比较字  |
|    cmpl    |         | 比较双字 |
|    cmpq    |         | 比较四字 |
|            |         |          |
| TEST S1,S2 |  S1&S2  |   测试   |
|   testb    |         | 测试字节 |
|   testw    |         |  测试字  |
|   testl    |         | 测试双字 |
|   testq    |         | 测试四字 |

### 访问条件码

不直接读取条件码，而是通过其他方式使用它：

- 通过条件码的组合将一个字节设置为 0 或 1。
- 根据条件跳转到程序的其它部分
- 有条件地传输数据

根据条件码组合设置字节的指令为`set`指令。它的目的操作数是低位单字节寄存器元素之一，或是一个字节的内存位置，指令会将这个字节设置成 0 或者 1。

|  指令   | 同义名 |              效果               | 设置条件  |
| :-----: | :----: | :-----------------------------: | :-------: |
| sete D  |  setz  |        D $\leftarrow$ ZF        |  相等/零  |
| setne D | setnz  |       D $\leftarrow$ ~ZF        | 不等/非零 |
| sets D  |        |        D $\leftarrow$ SF        |   负数    |
| setns D |        |       D $\leftarrow$ ~SF        |  非负数   |
| setg D  | setnle | D $\leftarrow$ ~(SF ^ OF) & ~ZF |  有符号>  |
| setge D | setnl  |    D $\leftarrow$ ~(SF ^ OF)    | 有符号>=  |
| setl D  | setnge |     D $\leftarrow$ SF ^ OF      |  有符号<  |
| setle D | setng  |  D $\leftarrow$ SF ^ OF \| ZF   | 有符号<=  |
| seta D  | setnbe |    D $\leftarrow$ ~CF & ~ZF     |  无符号>  |
| setae D | setnb  |       D $\leftarrow$ ~CF        | 无符号>=  |
| setb D  | setnae |        D $\leftarrow$ CF        |  无符号<  |
| setbe D | setna  |     D $\leftarrow$ CF \| ZF     | 无符号<=  |

### 跳转指令

跳转指令会导致程序切换到一个全新的位置。这个位置通常由标号$Label$指明。

`jmp`指令是无条件跳转。它既可以*直接*跳转，跳转目标是作为指令的一部分编码的。也可以是*间接*跳转，跳转目标从寄存器或内存位置读出。

|      指令      | 同义词 |     跳转条件     |   描述   |
| :------------: | :----: | :--------------: | :------: |
|  jmp $Label$   |        |        1         | 直接跳转 |
| jmp $*Operand$ |        |        1         | 间接跳转 |
|   je $Label$   |   jz   |        ZF        |   相等   |
|  jne $Label$   |  jnz   |       ~ZF        |  不相等  |
|   js $Label$   |        |        SF        |   负数   |
|  jns $Label$   |        |       ~SF        |  非负数  |
|   jg $Label$   |  jnle  | ~(SF ^ OF) & ~ZF | 有符号>  |
|  jge $Label$   |  jnl   |    ~(SF ^ OF)    | 有符号>= |
|   jl $Label$   |  jnge  |     SF ^ OF      | 有符号<  |
|  jle $Label$   |  jng   | (SF ^ OF) \| ZF  | 有符号<= |
|   ja $Label$   |  jnbe  |    ~CF & ~ZF     | 无符号>  |
|  jae $Label$   |  jnb   |       ~CF        | 无符号>= |
|   jb $Label$   |  jnae  |        CF        | 无符号<  |
|  jbe $Label$   |  jna   |     CF \| ZF     | 无符号<= |

#### 跳转指令的编码

- PC-relative: PC相对编码，将目标指令的地址与紧跟在跳转指令的后面那条指令之间的差作为编码，可以编码为1，2，或4个字节。
- “绝对”地址：用四个字节直接指定目标。

```armasm
0: 48 89 f8            mov     %rdi,%rax
3: eb 03               jmp     8 <loop+0x8>
5: 48 d1 f8            sar     %rax
8: 48 85 c0            test    %rax,%rax
b: 7f f8               jg      5 <loop+0x5>
d: f3 c3               repz retq
```

可以看到jmp指令所在行左边*0x03*作为编码，它加上下一条指令的位置*0x5*就是要跳转的位置*0x8*。

类似地，jg指令要跳转的位置是*0x5*,将*0x5*减去下一条指令的位置*0xd*,得到*0xf8*作为编码。

#### 用条件控制来实现条件分支

`CMP`或`TEST`指令改变条件码，然后使用条件跳转指令进行跳转实现条件分支。

#### 用条件传送来实现条件分支

使用*控制*的条件转移简单通用，但非常低效。

一种替代的策略是使用*数据*的条件转移。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。

只有在一些受限制的情况中，这种策略才可行，但如果可行，就可以用一条简单的*条件传送*指令来实现它。

##### 为什么条件传送更快？

CPU通过使用*流水线*来获取高性能。在流水线中，一条指令的处理要经过一系列的阶段，每个阶段执行所需操作的一部分。而流水线要获取高性能，需要重叠连续指令的步骤，例如，在取一条指令的同时，计算它前面指令的算数运算。这要求能够事先确定执行的指令序列，以保持流水线中充满了待执行的指令。当机器遇到条件跳转时，只有当分支条件求值完成之后，才能决定分支往哪边走。处理器采用*分支预测逻辑*来猜测跳转指令是否执行。只要猜测比较可靠，流水线就会充满指令，而错误预测会导致严重的惩罚。条件传送不需要进行这样的预测，也就没有惩罚。

条件传送指令有两个操作数：源寄存器或者内存地址$S$，目的寄存器$R$。 源和目的的值可以是16位，32位，64位，不支持单字节传送。汇编器可以从目标寄存器的名字判断条件传送指令的操作数长度，所以对所有的操作数长度，都可以使用同一个指令名字。

|     指令     | 同义名  |     传送条件     |   描述   |
| :----------: | :-----: | :--------------: | :------: |
| cmove $S,R$  |  cmovz  |        ZF        |   相等   |
| cmovne $S,R$ | cmovnz  |       ~ZF        |  不相等  |
| cmovs $S,R$  |         |        SF        |   负数   |
| cmovns $S,R$ |         |       ~SF        |  非负数  |
| cmovg $S,R$  | cmovnle | ~(SF ^ OF) & ~ZF | 有符号>  |
| cmovge $S,R$ | cmovnl  |    ~(SF ^ OF)    | 有符号>= |
| cmovl $S,R$  | cmovnge |     SF ^ OF      | 有符号<  |
| cmovle $S,R$ | cmovng  | (SF ^ OF) \| ZF  | 有符号<= |
| cmova $S,R$  | cmovnbe |    ~CF & ~ZF     | 无符号>  |
| cmovae $S,R$ | cmovnb  |       ~CF        | 无符号>= |
| cmovb $S,R$  | cmovnae |        CF        | 无符号<  |
| cmovbe $S,R$ | cmovna  |     CF \| ZF     | 无符号<= |

不是所有的条件表达式都可以用条件传送来编译。最重要的是，无论测试结果如何，都会对条件的两个结果求值，如果求值的过程中可能产生错误条件或者副作用，就会导致非法的行为。

条件传送不总是会提高代码的效率，如果求值需要大量的计算，就有可能不划算。
