# 排序

## 插入排序

像插牌一样，假设要从小到大排序。将待插的牌从后往前一个一个和已经排好的牌比较。如果待插牌比当前牌小，则当前牌后移一位，待插牌继续往前比。直到待插的牌比当前牌大，由于前面的比较过程中已经留好了位置，直接把待插的牌放在当前牌之后就行了。

```Java
public void sort(int[] a) {
    int len = a.length;
    int k = 1;
    //一次循环排好一张牌
    while (k < len) {
        int key = a[k]; //key为待插的牌， 把它从a[k]中拿出来也腾出了一个空位
        int i = k-1;
        while (i > -1 && key < a[i]) {
            a[i+1] = a[i]; //把比较了的牌后移放在空位里
            i--;
        }
        a[i+1] = key;
        k++;
    }
}
```

### 分析

假设输入为$n$

#### 最好情况

最好的情况就是输入为一个已经排好的序列。里层的循环内部并没有执行，所以最好情况是关于$n$的线性函数。

#### 最坏情况

最坏情况是一个反向排序的序列。每次内循环都执行$k$次，$k$从1增长到$n-1$，加起来得到最坏情况是关于$n$的二次函数