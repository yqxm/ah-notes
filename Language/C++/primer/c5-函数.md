# 函数

## 基础

实参是形参的初始值。

### 局部对象

名字有作用域，对象有生命周期

- 名字的作用域是程序文本的一部分，名字在其中可见。
- 对象的生命周期是程序执行过程中该对象存在的一段时间。

形参和函数体内部定义的变量都是局部变量，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域中同名的其它所有声明中。

#### 自动对象

对普通局部变量对应的对象来说，当函数的控制路径经过变量定义语句时创建该对象，当到达定义所在的块末尾时销毁它。值存在与块执行期间的对象为自动对象。当块的执行结束后，块中创建的自动对象的值就变成未定义的了。

#### 局部静态对象

将局部变量定义成static类型从而使对象的生命周期贯穿函数调用及之后的时间。局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并在程序终止时销毁。

### 函数声明

函数的名字也必须在使用之前声明。函数只能定义一次，但可以声明多次。

函数声明无须函数体，所以也不需要形参的名字。但加上形参名更好理解

在头文件中进行函数声明。

### 分离式编译

分离式编译允许把程序分割到几个文件中去，每个文件独立编译。如果修改了其中一个源文件，那么只需要重新编译那个改动了的文件。

## 参数传递

形参初始化的机理与变量初始化一样。

形参的类型决定了形参和实参的交互方式。如果形参时引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。

当形参是引用类型时，它对应的实参被引用传递或者函数被传引用调用。引用形参是它对应的实参的别名。

当实参的值被拷贝给形参时，形参和实参时两个相互独立的对象。即实参被值传递或函数被传值调用。

### 传值参数

传值参数中，函数对形参的所有操作都不会形象实参。当参数是指针时，拷贝的是指针，拷贝之后，两个指针是不同的指针。

### 传引用参数

引用形参允许函数改变一个或多个实参的值。

拷贝大的类类型对象或者容器对象比较低效，甚至有的类类型根本不支持拷贝操作。可以使用引用来避免拷贝或者无法拷贝。

使用引用形参返回额外信息，例如获取多个返回值，在外部定义变量，将其作为引用形参传入函数。

### const形参和实参

当用实参初始化形参时会忽略掉顶层const。也就是说形参的顶层const被忽略掉了。当形参有顶层const时，传给它常量对象或者非常量对象都是可以的。

C++中允许定义若干具有相同名字的函数，但需要形参列表有明显的区别，因为顶层const会被忽略，所以不能用顶层const来区别不同函数。

#### 尽量使用常量引用

非常量引用可能给函数调用者一种可以修改实参的误导。此外，非常量引用也会极大地限制函数所能接受的实参类型。

### 数组形参

因为数组不能被拷贝，且使用数组时通常会将其转换成指针。所以，无法以值传递的方式使用数组参数。当为函数传递一个数组时，实际上传递的是指向数组首元素的指针。

因为数组是以指针的形式传递给函数的，所以一开始函数并不知道数组的确切大小，调用者应该提供一些额外信息。

- 使用标记指定数组大小：类似于C风格字符串的阶数标志
- 使用标准库规范：传递指向数组首元素和尾后元素的指针
- 显式传递一个表示数组大小的形参

#### 数组形参和const

当函数不需要对数组元素执行写操作的时候，数组形参应该是指向const的指针。

#### 数组引用形参

```cpp
// 括号必不可少，表示arr是数组的引用。如果没有括号则变成了有10个引用的数组，而这是不存在的
void print(int (&arr)[10]) {

}
```

引用形参绑定到了对应的数组上，但这样有一个缺点，函数只能作用于大小为10的数组。

### main: 处理命令行选项

```cpp
int main(int argc, char *argv[]) {

}
```

argc表示参数的数量，argv的第一个元素指向程序的名字或者空字符串，接下来的元素依次传递命令行提供的实参。

### 含有可变形参的函数

如果函数的实参数量未知但全部实参的类型相同，我们可以使用initializer_list类型的形参。

initializer_list也是一种模板类型，且对象中的元素永远是常量值。

```cpp
void error_msg(initializer_list<string> il) {

}
```

## 返回类型和return语句

不要返回局部对象的引用或指针

### 引用返回左值

调用一个返回引用的函数得到左值，可以像使用其他左值那样来使用返回引用的函数的调用，特别地，可以为返回类型是非常量引用的函数的结果赋值。

### 列表初始化返回值

### 递归

main函数不能调用自身

### 返回数组指针

#### 使用类型别名

```cpp
using arrT = int[10];

arrT* func(int i);
```

func返回一个指向含有10个int的数组的指针。

#### 函数指示返回数组维度

```cpp
int (*func(int i))[10];
```

- `(*func(int i))` 表示可以对函数调用的结果执行解引用操作。
- `(*func(int i)[10])` 表示解引用func的调用将得到一个大小为10的数组。
- `int (*func(int i)[10]` 表示数组的元素的类型为int。

#### 尾置返回类型

C++11的新特性。尾置返回类型跟在形参列表后面并以`->`符号开头。在本应该出现返回类型的地方放置auto。

```cpp
int a[5] {1,2,3,4,5};
auto foo(int i) -> int* {
    return a;
}

auto boo(int i) -> int(*)[5] {
    return &a;
}
```

foo返回了数组的首个元素的指针，boo返回一个指向包含5个元素的数组的指针

#### 使用decltype

如果知道函数的返回指针指向哪个数组，可以使用decltype关键字。

```cpp
int odd[] = {1,3,5,7,9};

decltype(odd) *arrPtr() {
    return &odd; 
}
```

decltype并不负责把数组类型转换成对应的指针，所以decltype的结果是个数组，要想表示arrPtr返回指针还必须在函数声明时附加`*`。

## 重载

### 重载和const形参

顶层const不影响传入函数的对象。一个拥有顶层const的形参无法和另一个没有顶层const的形参区分开来。

```cpp
void foo(Phone);
void foo(const Phone);  // 重复声明

void foo(Phone*);
void foo(Phone* const); // 重复声明 参数是指针，它给定义了顶层const
```

如果形参是某种类型的指针或引用，通过区分其指向的是常量对象还是非常量对象可以实现函数重载。

```cpp
void boo(Account&);
void boo(const Account&);   // 参数是指向常量的引用

void boo(Account*);
void boo(const Account*);   // 参数是指针，它指向一个常量
```

#### const_cast和重载

```cpp
const string &shorterString(const string &s1,const string &s2) {
    return s1.size() <= s2.size() ? s1 : s2;
}
```

上面这个例子中，虽然传入的实参可能是非常量的，但返回的结果是常量引用。这时可以使用const_cast

```cpp
string &shorterString(string &s1, string &s2) {
    auto &r = shorterString(const_cast<const string&>(s1), const_cast<const string&>(s2));
    return const_cast(string&)(r);
}
```

## 特殊用途语言特性

### 默认实参

给函数参数赋予一个默认值，要使用这个默认值只需要在调用函数的时候将它忽略。函数调用实参按照位置解析，默认实参负责填补函数调用缺少的尾部实参。所以只能忽略尾部的实参。
局部变量不能作为默认实参，除此之外，只要表达式的类型能转换成所需的类型，就能作为默认实参。

```cpp
int sum(int a = 0, int b = 0) {
    return a+b;
}

int main() {
    int s = sum();
    int s1 = sum(,2); // 错误，只能忽略尾部实参
    int s2 = sum(1);
}
```

### 内联函数和constexpr函数

#### 内联函数

使用函数具有很多好处，但调用函数具有一定的开销。使用内联函数可以避免这种开销，提升性能。只需要在函数声明时加上`inline`关键字。

内联函数应该在短的，直接的，频繁使用的函数中使用。不要在递归函数中使用它。

#### constexpr函数

constexpr是指能用于常量表达式的函数。使用时有一些限制：1. 所有形参和返回值都必须是字面值类型。2. 函数体中必须有且只有一条return语句。

constexpr可以包含其他语句，只要这些语句在运行时不执行任何操作就行。如空语句，类型别名以及using声明。

允许constexpr函数的返回值并非一个常量。

建议内联函数和constexpr函数放在头文件内。

### 调试帮助

assert和NDEBUG

## 函数匹配

1. 选定重载函数集
2. 选出能被调用的可行函数
3. ①该函数的每个实参的匹配不劣于其他函数②该函数有一个实参的匹配优于其他函数③如果多个函数满足前两个条件，编译器报错。

### 实参类型转换

转换等级：

1. 精确匹配
    - 实参类型和形参类型相同。
    - 实参类型从数组类型或函数类型转换成对应的指针类型
    - 向实参添加顶层const或者从实参中删除顶层const。
2. 通过const转换实现的匹配。
3. 通过类型提升实现的匹配。
4. 通过算数类型转换或指针转换实现的匹配

如果重载函数的区别在于它们的引用类型的形参是否引用了const，或者指针类型的形参是否指向const，则当调用发生时编译器通过实参是否是常量来决定选择哪个函数。

## 函数指针
