# 程序的机器级表示(x86-64) 

## 程序编码

```bash
linux> gcc -Og -o p p1.c p2.c
```

编译选项`-Og`告诉编译器不进行优化，生成符合原始`C`结构的机器级代码。

### 机器级代码

可见的处理器状态：

- 程序计数器：给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件：包含16个命名的位置，分别存储64位的值。
- 条件码寄存器：保存最近的算数或逻辑指令的状态信息。实现控制或数据流中的条件变化
- 一个向量寄存器可以存储一个或多个整数或浮点数值。

一条机器指令只执行一个基本操作。

```bash
linux> gcc -Og -c  mstore.c
```

选项-c编译并汇编代码

```bash
linux> objdump -d mstore.o
```

使用`Objdump -d`来进行反汇编

机器代码和它的反汇编的一些特性：

- x86-64指令的长度从1-15不等。越不常用的指令越长。
- 设计指令代码的格式是：从某个给定位置开始，可以将字节唯一的解释成机器指令
- 反汇编器根据机器代码文件中的字节序列来确定汇编代码。
- 反汇编器使用的指令命名规则和GCC生成的汇编代码有细微的差别

## 数据格式

Intel用"字"代表16位数据类型。32位为双字，64位为四字

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小（字节） |
| ------ | ------------- | ------------ | ------------ |
| char   | 字节          | b            | 1            |
| short  | 字            | w            | 2            |
| int    | 双字          | l            | 4            |
| long   | 四字          | q            | 8            |
| char*  | 四字          | q            | 8            |
| float  | 单精度        | s            | 4            |
| double | 双精度        | l            | 8            |

大多数gcc生成的汇编代码都有一个后缀，表明操作的数据大小。

## 访问信息

一个x86-64cpu包含一组16个存储64位值的**通用目的寄存器**。这些寄存器用来存储整数和指针。

指令可以对寄存器的低位字节进行操作。操作1个字节，2个字节，4个字节或8个字节。操作可能对高位字节有影响。

不同的寄存器扮演不同的角色。

### 操作数指示符

三种类型

- 立即数：用来表示常数值
- 寄存器：用来表示寄存器的内容，用符号$r_a$表示任意寄存器a,$R[r_a]$表示它的值
- 内存引用：根据计算出来的地址访问内存位置。用$M_b[Addr]$来表示在内存$Addr$开始的$b$个字节值的引用

内存引用的寻址模式： $Imm(r_b, r_i, s)$是最常用的形式。它的有效地址为$R[r_b]+R[r_i]*s$。

### 数据传送指令

将数据从一个位置传送导一个位置

| 指令    |       | 效果       | 描述           |
| :------ | ----- | ---------- | -------------- |
| $MOV$   | $S,D$ | $D\gets S$ | 传送           |
| movb    |       |            | 传送字节       |
| movw    |       |            | 传送字         |
| movl    |       |            | 传送双字       |
| movq    |       |            | 传送四字       |
| movabsq | $I,R$ |            | 传送绝对的四字 |

源操作数指定的是一个立即数，存储在寄存器或者内存中。目的操作数是一个位置，寄存器或者内存地址。

x86-64中两个操作数不能都指向内存的位置。

一般情况下，`MOV`指令只会更新目的操作数指定的寄存器字节或者内存位置。唯一例外是以寄存器为目的传送双字时，会把所有高位设置为0。

常规的`movq`指令只能传送32位补码的立即数作为源操作数，然后将其符号扩展到64位。而`movabsq`能够以任意64位立即数作为源操作数，并且只能以内存器作为目的。

当将较小的值复制到较大的值时：

- `MOVZ`类指令将目的剩余字节填充为0
- `MOVS`类指令将通过符号扩展来填充，把源操作的最高位进行复制
