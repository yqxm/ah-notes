- **获取进程ID**
	- ```C
	  #include <sys/types.h>
	  #include <unistd.h>
	  
	  pid_t getpid(void);				// 返回调用进程的PID
	  pid_t getppid(void);			// 返回父进程的PID
	  ```
	- `pid_t`为整数，在linux系统上它在`types.h`中被定义为`int`
- **创建和终止进程**
	- **进程的三个状态**
		- 运行。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
		- 停止。进程的执行被挂起，且不会被调度。
			- 收到`SIGSTOP SIGTSTP SIGTTIN SIGTTOU`信号时停止。
			- 收到`SIGCOUT`时，进程再次开始运行。
		- 终止。 进程永远停止，原因：
			- 收到一个信号，信号的默认行为是终止进程
			- 从主程序返回
			- 调用`exit()`函数。`exit`函数以`status`退出状态来终止进程
				- ```C
				  #include <stdlib.h>
				  
				  void exit(int status);
				  ```
	- **创建子进程**
		- ```C
		  #include <sys/types.h>
		  #include <unistd.h>
		  
		  pid_t fork(void);
		  ```
		- 通过`fork()`函数创建一个新的子进程。
			- 子进程得到与父进程用户级虚拟地址空间相同的一份副本
			- 子进程获得与父进程任何打开文件描述符相同的副本，意味着可以读写父进程中打开的任何文件。
			- 子进程和父进程并发运行
		- `fork()`函数返回两次：一次是在父进程中，一次是在新创建的子进程中。
			- 在父进程中，`fork()`返回子进程的**PID**。
			- 在子进程中，`fork()`返回**0**。
	- **回收子进程**
		- [[进程的回收]]
		- 一个进程可以通过调用`waitpid`函数来等待它的子进程终止或者停止。
		- ```C
		  #include <sys/types.h>
		  #include <sys/wait.h>
		  
		  pid_t waitpid(pid_t pid, int *statusp, int options);
		  ```
		-