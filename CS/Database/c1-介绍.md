# Intro

## The Evolution of Database Systems

Database: data managed by DBMS.

The DBMS is expected to:

1. Allow users to create databases and specify schemas.(use *DDL*)
2. Give users the ability to query the data and modify the data.(use *DML*)
3. Support the storage of large amount of data over a long period of time, allowing efficient access to the data for queries and database modifications.
4. Enable *durability*.The recovery of the database in the face of failures, errors of many kind or intentional misuse.
5. Control access to data from many users at once, without allowing unexpected interactions among users (called *isolation*) and without actions on the data to be performed partially not completely (called *atomicity*).

### Early DBMS

Evolved from file system.

- do not directly support a query language in data.
- support for create specify schema is limited to the creation of directory structure for files.
- do not support durability.
- do not satisfy isolation and atomicity.

### Relational DBMS

- data organized as tables called *relations*
- Query could be expressed in a very high-level language, like *sql*.

#### Information integration

Joining the information contained in many realated database into a whole.

solutions:

- data warehouse: copy from many legacy database periodically.
- middleware: support an integrated model of the data of various databases.Translate betwwen this model and the actual model used by each database.

## Overview of a DBMS

command source:

- Conventional users and application programs that ask for data or modify data.
- DBA: a person responsible for the schema of the database.

### DDL

*metadata*: the schema information for the database.

DDL commands parsed by a DDL processor and passed to execution engine, which then go through the index/file/record manager to alter the *metadata*.

### Overview of Query Processing

DML, two kind of command handled by two separate subsystems.

- modify content of the database
- extract data from the database

#### Answering the query

1. *query compiler* parse and optimize the query, pass the quey plan to *execution engine*.
2. The *execution engine* issue a squence of requests for small piece of data to a resource manager that knows about *data files*(holding relations), the format and size of records in those files and *indexed files*.
3. The request for data are passed to the *buffer manager*.
4. *buffer manager* take data for secondary storage(disk) to main-memory buffers.

The buffer manager communicate with a storage manager to get data from disk. The storage manager might involve operating-system commands, but more typically, the DBMS issues commands directly to the disk controller.

#### Transaction

Queries and other DML actions are grouped into *transactions*, which must be executed atomically and in isolation from one another.

The execution of *transaction* must be durable.

Transaction processor major parts:

- *concurrency-control manager*: responsible for assuring atomicity and isolation of trasactions.
- *logging and recovery manager*: responsible for the durability for trasactions.

### Storage and Buffer Management

The *storage manager* controlls the placement of data indisk and its movement between disk and main memory.

The *buffer manager* is responsible for patitioning the avalible main memory into *buffers*, which are page-sized regions into which disk blocks can be transfferd.

To transffer, DBMS need information from disk that will interact with *buffers* and *buffer manager*, even *execution engine*.

The information may include:

- *data*: the contents of the database itself.
- *metadata*: the database schema that descrives the structure of, and constrains on, the database.
- *log records*: information about recent changes to the database
- *statistics*: information gathered and stored by the DBMS.
- *indexes*: data structures that support efficient access to the data.

### Transaction Processing

The *transaction manager* accepts *transaction commands* from an application, which tell the transaction manager when transactions begin and end, as well as information about the expectations of the application.

The transaction processor perform the following tasks:

- *Logging*
  - every change in database is logged separately on disk.
  - *log manager* assure that when system failure occurs, a *recovery manager* will be examine the log of changes and restore the database to some consistent state.
  - The log manager initially writes the log in buffers and negotiate with the buffer manager to make sure that buffers are written to disk at appropriate times.
- *Concurrency control*
  - The scheduler must assure that the individual actions of multiple trasactions are executed in such an order that the net effect is the same as if the transactions had in fact executed in their entirety, one-at-a-time.
  - The typical scheduler does its work by maintaining *locks* on certain pieces of database. Locks are generally stored in main-memory *lock table*.
- *Deadlock resolution*
  - The transaction manager has the responsibility to intervene and cancel ("rollback" or "abort") one or more transactions to le the others proceed.

#### ACID

- "A" stands for "atomicity", the all-or-nothing execution of transactions.
- "I" stands for "isolation", the fact that each transaction must appear to be executed as if no other transaction is executing at the same time.
- "D" stands for "durability", the condition that the effect on the database of transaction must never be lost, once the transaction has completed.
- "C" stands for "consistency".All databases have consistency constrains, or expectations about relationships among data elements.Transactions are expected to preserve the consistency of the database.

### The Query Processor

The query processor is represented by two components.*query compiler* and *execution engine*

#### The Query Compiler

It translate the query into an internal form called *query plan*.Often the operations in a query plan are implementations of "relational algebra" operations.

The query compiler three major units:

- *query parser*
- *query preprocessor*, which performs semantic checks on the query, and performing some tree transformations to turn the parse tree into a tree of algebratic operators representing the initial query plan.
- *query optimizer*

#### The execution engine

It has the responsibility for executing each of the steps in the chosen query plan. 

It interacts with most of the other components of the DBMS, either directly or through the buffers. 

It must get the data from database in to buffers in order to manipulate that data.

It interact with the scheduler to avoid accessing data that is locked.

It interact with the log manager to make sure that all database changes are properly logged.