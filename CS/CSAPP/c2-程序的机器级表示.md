# 程序的机器级表示(x86-64)

## 程序编码

```bash
linux> gcc -Og -o p p1.c p2.c
```

编译选项`-Og`告诉编译器不进行优化，生成符合原始`C`结构的机器级代码。

### 机器级代码

可见的处理器状态：

- 程序计数器：给出将要执行的下一条指令在内存中的地址
- 整数寄存器文件：包含 16 个命名的位置，分别存储 64 位的值。
- 条件码寄存器：保存最近的算数或逻辑指令的状态信息。实现控制或数据流中的条件变化
- 一个向量寄存器可以存储一个或多个整数或浮点数值。

一条机器指令只执行一个基本操作。

选项`-c`编译并汇编代码

```bash
linux> gcc -Og -c  mstore.c
```

使用`Objdump -d`来进行反汇编

```bash
linux> objdump -d mstore.o
```

机器代码和它的反汇编的一些特性：

- x86-64 指令的长度从 1-15 不等。越不常用的指令越长。
- 设计指令代码的格式是：从某个给定位置开始，可以将字节唯一的解释成机器指令
- 反汇编器根据机器代码文件中的字节序列来确定汇编代码。
- 反汇编器使用的指令命名规则和 GCC 生成的汇编代码有细微的差别

## 数据格式

Intel 用"字"代表 16 位数据类型。32 位为双字，64 位为四字

| C 声明 | Intel 数据类型 | 汇编代码后缀 | 大小（字节） |
| ------ | -------------- | ------------ | ------------ |
| char   | 字节           | b            | 1            |
| short  | 字             | w            | 2            |
| int    | 双字           | l            | 4            |
| long   | 四字           | q            | 8            |
| char\* | 四字           | q            | 8            |
| float  | 单精度         | s            | 4            |
| double | 双精度         | l            | 8            |

大多数 gcc 生成的汇编代码都有一个后缀，表明操作的数据大小。

## 访问信息

一个 x86-64cpu 包含一组 16 个存储 64 位值的**通用目的寄存器**。这些寄存器用来存储整数和指针。

指令可以对寄存器的低位字节进行操作。操作 1 个字节，2 个字节，4 个字节或 8 个字节。操作可能对高位字节有影响。

不同的寄存器扮演不同的角色。

### 操作数指示符

三种类型

- 立即数：用来表示常数值
- 寄存器：用来表示寄存器的内容，用符号$r_a$表示任意寄存器 a,$R[r_a]$表示它的值
- 内存引用：根据计算出来的地址访问内存位置。用$M_b[Addr]$来表示在内存$Addr$开始的$b$个字节值的引用

内存引用的寻址模式： $Imm(r_b, r_i, s)$是最常用的形式。它的有效地址为$R[r_b]+R[r_i]*s$。

### 数据传送指令

#### MOV 类

源操作数制定为一个立即数，存储在寄存器或者内存中。目的操作数制定为一个位置，要么是寄存器，要么是内存地址。x86-64 规定源操作数和目的操作数不能都指向内存。

`mov`指令后可以跟`b`、`w`、`l`、`q`。分别表示移动的是字节，字，双字，四字。

大多数情况下，`mov`只会改变对应长度的数据。但例外情况是，当`movl`指令的目的是寄存器时，寄存器的高位 4 字节会设置为 0。原因是 x86-64 的惯例，任何为 32 位寄存器生成值的操作都会把该寄存器的高 32 位设置为 0。

##### movabsq

常规的`movq`只能以表示为 32 位补码的立即数作为源操作数，然后把这个值符号扩展到 64 位存储到目标位置。而`movabsq`能够以任意 64 位立即数作为源操作数，并且只能以寄存器作为目的。

#### MOVZ 和 MOVS

这两类指令以内存或寄存器作为源，以寄存器作为目的，并且将较小的源传送到较大的目的。`movz`将目的的高位填充为 0，`movs`根据源的最高位进行符号扩展。

例子：

- `movzbw`：将做了零扩展的字节传送到字
- `movsbw`：将做了符号扩展的字节传送到字

理论上应该有`movzlq`，但可以通过`movl`实现，所以没有`movzlq`。

### 压入和弹出栈操作

push 操作将数据压入栈中。pop 操作将数据从栈中弹出。都只有一个操作数

栈遵循后进先出的原则。出的位置被称为“栈顶”。

在 x86-64 中，栈向下增长。“栈顶”在最低位，栈指针`%rsp`指向栈顶的位置。

将一个四字值压入栈中，栈指针减 8，然后将值写入新的栈顶地址

## 算数和逻辑操作

### 加载有效地址

`leaq`指令将有效地址写入到目的操作数。目的操作数必须为寄存器

第一个操作数的形式是内存引用，这样它就可以进行一些简单的计算。

### 一元操作

`INC`、`DEC`、`NEG`、`NOT`是一元操作。操作数既是源也是目的，操作数为寄存器或者内存位置。

`incq(%rsp)`会使栈顶的 8 字节元素加 1。

### 二元操作

`ADD`、`SUB`、`IMUL`、`XOR`、`OR`、`AND`是二元操作。第二个操作数既是源也是目的。

第一个操作数可以是寄存器，立即数或者内存地址。第二个操作数可以是寄存器或者内存地址。当第二个操作数是内存地址时，数据从内存读出，计算后在存储到内存中。

### 移位操作

`SAL`、`SHL`、`SAR`、`SHR`是移位操作。

第一个数给出移位量，可以是立即数，或者在单字节寄存器`%c1`中。第二个数给出要移位的数。

A 代表算数移位，H 代表逻辑移位。

理论上移位量可以达到$2^8-1$,但在 x86-64 中，移位量由`%cl`寄存器的低$m$决定，其中$2^m=w$。$w$代表要操作的数据值的位数。

### 特殊的算术操作

`imulq`有两种形式

- 双操作数：从两个 64 位操作数产生一个 64 位乘积
- 单操作数：计算两个 64 位补码值的全 128 位乘积。

`mulq`计算两个 64 位无符号值的全 128 位乘积。和单操作数时的`imulq`一样，要求一个参数必须存放在寄存器`%rax`中，另一个以源操作数给出。然后将乘积存放在`%rdx`（高 64 位）和`%rax`（低 64 位）中。

汇编器根据`imulq`的操作数来判断执行哪种操作。

除法和取模操作由单操作数`idivq`，`divq`来提供。将寄存器`%rdx`存储高 64 位，`%rax`来存储低 64 位作为被除数。除数由指令的操作数提供。商保存在`%rax`中，余数保存在`%rdx`中。

`cqto`指令没有操作数，它隐含读出`%rax`的符号位，并复制到`%rdx`的所有位

## 控制

### 条件码

除了整数寄存器，CPU 还维护了一组**单个位**的条件码寄存器，用来描述最近的算术或逻辑操作的属性。

最常用的条件码：

- CF：进位标志
- ZF：零标志
- SF：符号标志。最近的操作结果为负数
- OF：溢出标志

`leaq`指令不改变任何条件码，因为它是进行地址计算的。除它以外，之前算术逻辑操作下的指令都会设置条件码。对于逻辑操作，例如`XOR`会将进位和溢出操作设置为 0。对于移位操作，进位标志会设置成最后一个被移出的位，溢出标志设置为 0。`INC`和`DEC`会设置溢出和零标志，但不改变进位标志。

`CMP`和`TEST`只改变条件码而不改变任何其他寄存器。

`CMP`行为和`SUB`一样。如果操作数相等，ZF(零标志)设置为 1。其他标志可以判断两个数的大小

`TEST`行为和`AND`一样。典型的应用是，两个操作数相等，判断这个操作数是负数，0 还是正数。或者其中一个数为掩码，指示哪些位应该被测试。

### 访问条件码

根据条件码的
