# 链接

Linking is the process of collecting and combining various pieces of code and data into a single file that can be _loaded_ into memory and excuted.

Linking can be performed at _compile time_, when the source code is translated into machine code; at _load time_, when the program is loaded into memory and excuted by the _loader_; and even at _run time_, by application programs.

Linkers enable _separate compilation_.

## Compiler Drivers

<img src="https://raw.githubusercontent.com/yqxm/draw-images/main/20220512174816.png" style="zoom: 40%;" />

Most compilation systems provide a _compiler driver that invokes the language preprocessor, compiler, assembler, and linker, as needed on behalf of the user.

First, the driver runs the C preprocessor(cpp), which translate the C source file main.c into an ASCII intermediate file `main.i`.

```bash
cpp [other args] main.c /tmp/main.i
```

Next, the driver runs the C compiler(cc1), which translates `main.i` into an ASCII assembly-language file `main.s`.

```bash
cc1 /tmp/main.i -Og [other args] -o /tmp/main.s
```

Then, the driver runs the assembler(as), which translate `main.s` into a binary _relocatable object file_ `main.o`.

```bash
as [other args] -o /tmp/main.s /tmp/main.s
```

The driver goes througn the same process to generate `sum.o`.

Finally, it runs the linker program ld, which combines `main.o` and `sum.o`, along with the necessary system object files, to create the binary _executable object file_.

```bash
ld -o prg [system obj files and args] /tmp/main.o /tmp/sum.o
```

The shell invokes a function called _loader_, which copies the code and data in the executable file `prog` into memory, and then transfers control to the beginning of the program.

## Static Linking

_Static Linker_ such as the Linux LD program take as input a collection of relocatable object files and command-line arguments and generate as output a fully linked excutable object file.

The input relocatable object files consist of various code and data sections. Each section is a contiguous sequence of bytes. _Instructions_, _Initialized global variables_, _Uninitialized variables_ are in separate sections.

Linker's two main task:

- **Symbol resolution**: Object files define and reference _symbols_, where each symbol correspond to a function, a global variable, or a _static variable_. The purpose of symbol resolution is to associate each symbol _reference_ with exactly one symbole _definition_

- **Relocation**: Compilers and assemblers generate code and data sections that start at address 0. The linker _relocates_ these sections by associating a memory location with each symbol definition, and then modifying all of the references to those symbols so that they point to this memory location.

Basic fact: Object files are merely collections of blocks of bytes.

## Object files

Three forms of object files:

- Relocatable object file
- Excutable object file
- Shared object file

## Relocatable Object files

The _ELF header_ begins with a 16-byte sequence that describes the word size and byte ordering of the system that generate the file. The rest of the ELF header contains information that allows alinker to parse and interpret the object file

sections between ELF header and the section header:

- .text: the machine code of the compiled program
- .rodata: Read-only data such as the format strings in printf statemens and jump tables for switch statements
- .data: _Initialized_ global and static C variables.
- .bss: _Uninitialized_ global and static C variables, along with any global or static variables that are initialized to zero.
- .symtab: A _symbol table_ with information about functions and global variables that defined and referenced in the program.
- .rel.text: A list of locations in the .text section that will need to be modified when the linker combines this object file with others.
- .rel.data: Relocation information for any global variables that are referenced or defined by the module.
- .debug: A debugging symbol table with entries for local variables and typedefs defined in the program, global variables defined and referenced in the program, and the original C source file.
- .line: A mapping between line numbers in the original C source program and machine code instructions in the .text section.
- .strtab: A string table for the symbol tables in the .symtab and .debug sections and for the section names in the section headers.

## Symbols and Symbol Tables

Each relocatable object module has a table that contains the information about the symbols that are defined and referenced by it. There are three kind of symbols

- Global symbols that are defined by module m that can be referenced by other modules.
- Global symbols that are referenced by module m but defined by some other module.
- _Local symbols_ that are defined and referenced exclusively by module m.

## Symbol Resolution

The linker resolves symbol references by associating each reference with exactly one symbol definition from the symbol tables of its input relocatable object files.

It's straightforward for references to local symbols that are defined in the same module as reference. The compiler allows only one definition of each local symbol per module.

### How to resolve duplicate global symbols

At compile time, the compiler exports each global symbol to the assembler as either _strong_ or _weak_, and the assembler encodes this information implictly in the symbol table of the relocatable object file.

- Functions and initialized global variables get strong symbols.
- Uninitialized global variables get weak symbols.

Rules for dealing duplicate symbol names.

- Multiple strong symbols withe same name are not allowed.
- Given a strong symbol and multiple weak symbols with the same name, choose the strong symbol.
- Given multiple weak symbols with the same name, choose any of the weak symbols.

### Linking with Static Libraries

All compilation systems provide a mechanism for packaging related object modules into a single file called a _static library_, which can then be supplied as input to the linker.

Related functions can be compiled into separate object modules and the packaged in a single static library file. Application programs can use any of the functions defined in the library by specifying a single filename on the commandline.

```shell
# create static library
linux> gcc -c addvec.c multvec.c
linux> ar rcs libvector.a addvec.o multvec.o

# use static library
linux> gcc -c main2.c
linux> gcc -static -o prog2c main2.o ./libvector.a
```

### How linkers use static libraries to resolve references

During the symbol resolution phase, the linker scans the relocatable object files and archives left to right in the same sequential order that they appear on the compiler driver's command line.

During this scan, the linker maintains a set _E_ of relocatable object files that will merged to form the executable, a set _U_ of unresolved symbols, a set _D_ of symbols that have been defined in previous input files. Initially, _E_,_U_, and _D_ are empty.

- For each input file _f_ on the command line, the linker determines if _f_ is an object file or an archive. if _f_ is an object file, the linker adds _f_ to _E_, updates _U_ and _D_ to reflect the symbol definitions and references in _f_, and proceeds to the next input file.

- if _f_ is an archive, the linker attempts to match the unresolved symbols in _U_ against the symbols defined by the members of the archive. If some archive member _m_ defines a symbol that resolves a references in _U_, then _m_ is added to _E_, and the linker updates _U_ and _D_ to reflect the symbol definitions and references in _m_. This process iterates over the member object files in the archive until a fixed point is reached where _U_ and _D_ no longer change. At this point, any member object files not contained in _E_ are simply discarded and the linker proceeds to the next input file.

- If _U_ is nonempty when the linker finishes scanning the input files on the command line, it prints an error and terminates. Otherwise, it merges and relocates the object files in _E_ to build the output executable file.

This algorithm can result in some baffling link-time errors because the ordering of libraries and object files on the command line is significant. If the library that defines a symbol appears on the command line before the object file that references that symbol, then the reference will not be resolved and linkingwill fail.

The general rule for libraries is to place them at the end of the command line. If the libraries are not independent, they must be ordered.

## Relocation

Relocation consists of two steps:

1. Relocating sections and symbol definitions.
2. Relocating symbol references within sections.

### Relocation Entries

Whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a _relocation entry_.

The format of an ELF relocation entry.

```c
typedef struct {
    long offset;        /* Offset of the reference to relocate */
    long type:32,       /* Relocation type */
    symbol:32;          /* Symbol table index */
    long addend;        /* Constant part of relocation expression */
} ELF64_Rela;
```

Two basic relocation type:

- `R_X86_64_PC32`: Relocate a reference that uses a 32-bit PC-relative address.
- `R_X86_64_32`: Relocate a reference that uses a 32-bit absolute address.

### Relocation Symbol References

Relocation algorithm:

```text
foreach section s {
    foreach relocation entry r {
        refptr = s + r.offset;
        
        if (r.type == R_X86_64_PC32) {
            refaddr = ADDR(s) + r.offset;
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend -refaddr);
        }
        
        if (r.type == R_X86_64_32)
            *refptr = (unsigned) (ADDR(r.symbol) + r.addend);
    }
}
```

PC relative: Encode the difference between the address of the target instruction and the address of the instruction immediately following the jump.

## Executable Object Files

The format of an executable object file is similar to that of a relocatable object file.

ELF executable are designed to be easy to load into memory, with contiguous chunks of the executable file mapped to contiguous memory segments. This mapping is described by the _program header table_.

## Loading Executable Object Files

Any Linux program can invoke loader by calling the `execve` function. The loader copies the code and data in the executable object file from disk into memory and then runs the program by jumping to its first instruction, or _entry point_. This process is called _loading_.

Every running Linux program has a run-time memory image. On Linux x86-64 systems, the code segment starts at address `0x400000`, followed by the data segment. The run-time _heap_ follows the data segment and grows upward via calls the `malloc` library. _Heap_ followed by a region that is reserved for the shared modules. The user stack starts below the largest legal user address and grows down. The region above the stack is reserved for the code and data in _kernel_.

## Dynamic Linking with Shared Libraries

The disadvantages of static libraries:

- Programmers have to explictly relink their programs when the library updated.
- Duplicate standard functions in the text segment of each running process.

```bash
# create shared library
linux> gcc -shared -fpic -o libvector.so addve.c multvec.c

# use shared library
linux> gcc -o prog21 main2.c ./libvector.so
```

Shared Library:
    An object module that, at either run time or load time, can be loaded at arbitrary memory address and linked with a program in memory.

Dynamic Linker:
    Relocate shared librady's data and text to memory, then reloacte refference defined in shared library.

## Position-Independent Code

PIC:
    Code that can be loaded without needing any relocations.

PIC data reference:
    An interesting fact: No matter where we load an object module (include shared object module) in memory, the data segment is always the same distance from the code segment.
    Use that fact to build _global offset table_(GOT)

PIC fuction calls:
    Use _lazy binding_ that defers the binding of each procedure address until the first time its called.
    Use two data structures's complex interaction to implement _lazy binding_. GOT and PLT(_procedure linkage table).

## Library Interpositioning

Library Interpositioning: 
    Allows you to intercept calls to shared library functions and execute your own code.

Basic idea:
    Given some target function to be interposed on, you create wrapper function whose portotype is indentical to the target function. Using some particular interpositioning mechanism, you then trick the system into calling the wrapper function instead of target function.

Three kind of mechanism
    - Compile-Time Interpositioning
    - Link-Time Interpositioning
    - Run-Time Interpositioning
