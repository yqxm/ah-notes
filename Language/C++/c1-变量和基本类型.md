# 变量和基本类型

## 基本内置类型

| 类型        | 含义           | 最小尺寸      |
| ----------- | -------------- | ------------- |
| bool        | 布尔           | 未定义        |
| char        | 字符           | 8 位          |
| wchar_t     | 宽字符         | 16 位         |
| char16_t    | Unicode 字符   | 16 位         |
| char32_t    | Unicode 字符   | 32 位         |
| short       | short integer  | 16 位         |
| int         | integer        | 16 位         |
| long        | long integer   | 32 位         |
| long long   | long integer   | 64 位         |
| float       | 单精度浮点数   | 6 位有效数字  |
| double      | 双精度浮点数   | 10 位有效数字 |
| long double | 扩展精度浮点数 | 10 位有效数字 |

`char`可以存放机器基本字符集中任意字符对应的数字值。

`wchar_t` 可以存放机器最大扩展字符集中的任意字符。

`char16_t`,`char32_t`用于 Unicode 字符集。

`float` 32 位. `double` 64 位. `long double` 96 或者 128 位.

## 有符号和无符号

除了 `bool` 类型和扩展字符类型外，其他基本类型都分为有符号和无符号。

`char` 有三种类型：`char`，`signed char`，`unsigned char`。但只显示为后两种，`char` 的显示由编译器决定。

## 类型转换

- 非布尔类型的算数值转换为布尔类型时，0 为 false，其他为 true。
- 布尔类型转换为其他算数类型时, true 为 1，false 为 0。
- 浮点值转换为整数类型时，只保留小数点前的部分
- 整数值转换为浮点数时，小数部分记为 0，如果所占空间太大，会有精度损失
- 给无符号类型一个超出范围的值，结果为初始值对无符号最大值取模后的余数。
- 给有符号类型一个超出范围的值，结果是未定义的。

### 表达式包含无符号类型

当一个算数表达式既有无符号数又有 int 值时，那个 int 值会转换成无符号数。

## 字面量常量

字面值常量的形式和值决定了它的数据类型

### 整形和浮点字面值

- 以 0 开头表示八进制数
- 以 0x 开头表示 16 进制数

默认情况下，十进制字面值常量是有符号数，八进制和十六进制符号可能带也可能不带。

它的类型是能容纳它的类型中容量最小的那个。

### 字符和字符串字面值

- 单引号括起来的一个字符是 char 字面值
- 双引号括起来的是字符串字面值

### 指定字面值的类型

- 字符和字符串字面值：u，U，L，u8 前缀分别表示 `char16_t`，`char32_t`，`wchar_t`，`char`
- 整型字面值：u 或 U，l 或 L，ll 或 LL 后缀分别表示 无符号，`long`，`long long`。
- 浮点型字面值：f 或 F，l 或 L 后缀分别表示 `float`，`long double`。

### 布尔和指针字面值

true 和 false 是布尔字面值。

nullptr 是指针字面值

## 变量

### 初始化

初始化不是赋值，初始化是创建变量时赋予其一个初始值，赋值是把对象的当前值擦除，以一个新值来替代。

### 列表初始化

```cpp
int s = {0};
int s(0);
int s{0}
```

初始化对象或为对象赋新值都可以使用花括号括起来的新值。当用于内置类型的变量时，当初始值存在丢失信息的风险时，编译器将报错。

### 默认初始化

变量没有指定初值，则变量被默认初始化，变量被赋予默认值。

- 内置类型：定义于任何函数体之外的变量被初始化为0，而定义于函数体内部的变量不被初始化。

每个类各自决定其初始化对象的方式，是否允许不经初始化就定义对象也由类自己决定。绝大多数类都支持无须显式初始化而定义对象。

### 变量声明和定义的关系

- 声明使得名字为程序所知，一个文件如果想使用别处定义的名字则必须包含对那个名字的声明，规定了变量的类型和名字。
- 定义负责创建与名字关联的实体。申请了存储空间，可能会为变量赋初始值

使用 extern 关键字对变量进行声明而不定义。

```cpp
extern int i;       // 声明，而不定义
int j;              // 声明并定义
extern int k = 0;   // 声明并定义
```

变量能且只能被定义一次，但可以被多次声明。如果在多个文件中使用同一个变量，就必须将声明和定义分离。此时，变量的定义必须出现在且只能出现在一个文件中，而其他用到该变量的文件必须对其进行声明，却不能重复定义。

### 标识符

标识符由字母、数字和下划线组成，其中必须以字母或下划线开头。

## 复合类型

基于其他类型定义的类型。

### 引用

引用为对象起了另外一个名字，使用`&`来定义引用类型。

```cpp
int ival = 1024;
int &refVal = ival;
int &refVal2;           // 报错：引用必须初始化
```

定义引用时，程序把引用和它的初始值绑定在一起。引用无法被重新绑定，因此必须初始化。

引用只能绑定在对象上。一般情况下，引用类型要和绑定的对象类型严格匹配。

### 指针

- 指针本身是一个对象，允许对指针赋值和拷贝，允许在指针的生命周期内先后指向不同的对象。
- 指针不需要在定义时赋值。

使用`*`来定义指针，使用`&`来获取地址。使用`*`来访问指针指向的对象。

```cpp
int *ip;
int ival = 42;
int *p = &ival;

*p = 0;
```

一般情况下，指针的类型要和它所指向的类型严格匹配。

#### 指针值

- 指向一个对象
- 指向紧邻对象所占空间的下一个位置
- 空指针，指针没有指向任何对象
- 无效指针，上述情况之外的值

#### 空指针

```cpp
// 定义空指针的三种方式
int *p1 = nullptr;
int *p2 = 0;
int *p3 = NULL; // 需要 #include <cstdlib>
```

#### 其他指针操作

如果指针合法，就可以放在条件表达式中。如果指针的值为0，条件为 false。非0，条件为 true。

如果两个指针存放的地址值相同，则它们相等。相等可能有三种情况：

- 都为空
- 都指向同一个对象
- 都指向同一个对象的下一个地址

一个指针指向某对象，另一个指针指向另外对象的下一地址，也可能出现指针相同的情况。

#### void*指针

void* 可以存放任意对象的地址。

## const限定符

const 对象一旦创建就不能改变，所以必须对其进行初始化。

默认情况下，const 对象仅在文件内有效。

### const的引用

将引用绑定到 const 对象上，即为对常量的引用。对常量的引用不能修改它绑定的对象。

#### 初始化对const的引用

可以用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型即可。允许为一个常量引用绑定非常量的对象、字面值或者一般表达式。

对 const 的引用可能引用一个并非 const 的对象。

### 指针和const

指向常量的指针不能改变其所指对象的值。要存放常量对象的地址，只能使用指向常量的指针。

允许令一个指向常量的指针指向一个非常量的对象。

```cpp
const double pi = 3.14;
const double *cptr = &pi;   // cptr是一个指向常量的指针
int dval = 3.00;
cptr = &dval;               // cptr指向了非常量
```

#### const指针

指针本身也是对象，所以允许把指针本身定为常量。常量指针必须初始化，初始化完成后它指向的那个地址就不能再改变。

把`*`放在 const 关键字之前表示这个指针是一个常量。注意区别指向常量的指针

### 顶层const

顶层 const 表示指针本身是个常量，底层 const表示指针所指的对象是一个常量。

更一般的，顶层 const可以表示任意的对象是常量，底层 const 则与指针和引用等复合类型的基本类型那个把部分有关。

```cpp
const int  ci = 42;
const int cj = 24;
const int *p2 = &ci;
// p3作为一个常量指针指向的是一个常量，所以使用指向常量的指针（常量的地址）对其进行初始化，初始化后p3指向的地址不能改变
const int *const p3 = p2;          
cout << *p2 << " " << *p3 << endl;  // *p2是42 *p3是42
p2 = &cj;
cout << *p2 << " " << *p3 << endl;  // *p2是24 *p3是42
```

### constexpr和常量表达式

常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。字面值属于常量表达式，用常量表达式初始化的 const 对象也是常量表达式。

#### constexpr 变量

在复杂系统中，很难分辨一个初始值到底是不是常量表达式。C++11规定，允许将变量声明为 constexpr 类型以便由编译器来验证变量是否是一个常量表达式

#### 字面值类型

常量表达式的值需要在编译时就得到计算，因此声明为 constexpr 的类型需要有所限制。类型简单，值也显而易见的类型称为“字面值类型”，它们可以被使用在常量表达式中。

算数类型、引用和指针都属于字面值类型。作为 constexpr 时，引用和指针的初始值受到严格限制。一个 constexpr 指针的初始值必须是 nullptr 或者 0。

#### constexpr和指针

在constexpr声明中定义了一个指针，限定符constexpr仅对指针本身有效，与指针所指的对象无关。

```cpp
const int *p = nullptr;         // p是一个指向整数常量的指针
constexpr int *q = nullptr;     // q是一个指向整数的常量指针
```

## 处理类型

### 类型别名

```cpp
// typedef
typedef double wages;       // wages是double的同义词
typedef wages base, *p;     // base是double的同义词，p是double*的同义词

// 别名声明
using SI = Sales_item;
```

#### 指针、常量和类型别名

```cpp
typedef char *pstring;      // pstring是char*的类型别名
const pstring cstr = 0;     // cstr是一个指向char的常量指针
const pstring *ps;          // ps是一个指针，它的对象是指向char的常量指针

const char *cstr2 = 0;      // cstr2是一个指针，它指向的是char常量。 注意和上面的区别
```

### auto类型

使用 auto 来让编译器来分析表达式所属的类型。auto根据初始值来推算变量的类型，所以auto定义的变量必须有初始值。

#### 复合类型、常量和auto

使用引用初始化auto类型时，引用对象的类型为auto的类型

```cpp
int i = 0, &r = i;
auto a = r;         // auto 为 int
```

auto一般会忽略掉顶层const，同时底层const则会保留下来。
