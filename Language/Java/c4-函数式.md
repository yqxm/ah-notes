# Java函数式

## Lambda表达式

Lambda表达式产生函数，而不是类。虽然在JVM上所有东西都是类，但可以把它当成函数。

```java
h -> h + "s";

(h) -> h + "s";

() -> "s";

(h, n) -> h + n;

() -> {
    int a = 3;
    int b = 4;
    return a+b;
}
```

对于只有一个函数的接口，Lambda表达式可以很方便的创建一个类似匿名内部类的对象。

### 递归

Lambda表达式也可以写出递归的函数。但这个递归方法必须是一个实例变量或者静态变量。

## 方法引用

将类或对象的方法的名字赋给单方法接口来创建类似匿名内部类的对象。要求这个方法的参数和返回值要和接口中的方法一致。

```java
interface Callable {
    void call(String s);
}

class Describe {
    void show(String msg) {
        System.out.println(msg);
    }
}

class MethodReferences {

    public static void main(String[] args) {
        Describe d = new Describe();
        Callable c = d::show;
    }
}

```

### 无绑定方法引用

无绑定的方法引用需要传入对象。换句话说，要使用无绑定方法引用的接口的参数列表中需要定义那个方法引用的对象。

```java
class X {
    String f() { return "X::f()"; }
}
interface MakeString {
    String make();
}
interface TransformX {
    String transform(X x);
}
public class UnboundMethodReference {
    public static void main(String[] args) {
        // MakeString ms = X::f;
        TransformX sp = X::f;
        X x = new X();
        System.out.println(sp.transform(x));
    }
}
```

### 构造器方法引用

```java
class Dog {
    String name;
    int age = -1;
    Dog() {name = "stray";}
    Dog(String nm) {name = nm;}
    Dog(String nm, int yrs) {name=nm;age= yrs;}
}

interface MakeNoArgs {
    Dog make();
}

interface Make1Arg {
    Dog make(String nm);
}

interface Make2Args {
    Dog make(String nm, int age);
}

public class CtorReference {
    public static void main(String[] args) {
        MakeNoArgs mna = Dog::new;
        Make1Arg m1a = Dog::new;
        Make2Args m2a = Dog::new;

        Dog dn = mna.make();
        Dog d1 = m1a.make("Comet");
        Dog d2 = m2a.make("Ralph",4);
    }
}
```

## 函数接口
